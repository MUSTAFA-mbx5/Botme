# -*- coding: utf-8 -*-
"""Bot me Al MUSTAFA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dZ-uN7yPoXV5jqQ4hR8tbng9wtskn5ft
"""

!pip install pymupdf

!pip install python-docx

!pip install python-pptx

!pip install telethon

!pip install python-docx

!pip install matplotlib-venn

!apt-get -qq install -y libfluidsynth1

# https://pypi.python.org/pypi/pydot
!apt-get -qq install -y graphviz && pip install pydot
import pydot

!pip install cartopy
import cartopy

# Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø®ØµØµ Ù„Ù„Ø¨ÙŠØ¦Ø§Øª Ù…Ø«Ù„ Google Colab Ø£Ùˆ Jupyter Notebook
# Ø­ÙŠØ« ÙŠÙ…ÙƒÙ† ØªØ´ØºÙŠÙ„ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¹Ø¬Ø¨ '!'

print("Ø§Ù„Ø®Ø·ÙˆØ© 1: ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø²Ù… (apt)...")
# Ø§Ù„Ø£Ù…Ø± '!apt-get -qq update' Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù€ '!apt-get update' ÙˆÙ„ÙƒÙ†Ù‡ Ø£Ù‚Ù„ Ø¥Ø®Ø±Ø§Ø¬Ù‹Ø§ (quiet)
# Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ÙŠØ¯ Ø±Ø¤ÙŠØ© ÙƒÙ„ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§ØªØŒ Ø§Ø³ØªØ®Ø¯Ù…: !apt-get update
# Ø§Ø³ØªØ®Ø¯Ø§Ù… get_ipython().system() Ù‡Ùˆ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø£ÙƒØ«Ø± Ù…ÙˆØ«ÙˆÙ‚ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø¸Ø§Ù… ÙÙŠ IPython/Jupyter
try:
    get_ipython().system('apt-get -qq update')
    print("ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø²Ù… Ø¨Ù†Ø¬Ø§Ø­.")
except Exception as e:
    print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø²Ù…: {e}")
    print("Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ´ØºÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ø¨ØµÙ„Ø§Ø­ÙŠØ§Øª sudo Ø¥Ø°Ø§ ÙƒÙ†Øª ÙÙŠ Ø¨ÙŠØ¦Ø© Ù„ÙŠÙ†ÙƒØ³ Ù…Ø­Ù„ÙŠØ©.")
print("-" * 30)

print("Ø§Ù„Ø®Ø·ÙˆØ© 2: ØªØ«Ø¨ÙŠØª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ÙŠØ© Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù†Ø¸Ø§Ù… 'libarchive-dev'...")
# Ø§Ù„Ø®ÙŠØ§Ø± '-y' ÙŠØ¬ÙŠØ¨ Ø¨Ù€ "yes" ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù„Ù‰ Ø£ÙŠ Ø£Ø³Ø¦Ù„Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ«Ø¨ÙŠØª
# Ø§Ù„Ø®ÙŠØ§Ø± '-qq' Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª
try:
    get_ipython().system('apt-get install -y -qq libarchive-dev')
    print("Ø§ÙƒØªÙ…Ù„Øª Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ«Ø¨ÙŠØª 'libarchive-dev'.")
    # Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ£ÙƒÙŠØ¯ Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ù†Ø¬Ø§Ø­ Ù…Ù† apt-get -qqØŒ ÙˆÙ„ÙƒÙ† Ø¥Ø°Ø§ ÙØ´Ù„ØŒ Ø³ÙŠØ¸Ù‡Ø± Ø®Ø·Ø£.
except Exception as e:
    print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ«Ø¨ÙŠØª 'libarchive-dev': {e}")
print("-" * 30)

print("Ø§Ù„Ø®Ø·ÙˆØ© 3: ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø© Ø¨Ø§ÙŠØ«ÙˆÙ† 'libarchive' Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pip...")
# Ø§Ù„Ø®ÙŠØ§Ø± '-U' ÙŠØ¹Ù†ÙŠ Ø§Ù„ØªØ±Ù‚ÙŠØ© Ø¥Ù„Ù‰ Ø£Ø­Ø¯Ø« Ø¥ØµØ¯Ø§Ø± Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…Ø«Ø¨ØªØ© Ø¨Ø§Ù„ÙØ¹Ù„
# Ø§Ù„Ø®ÙŠØ§Ø± '-q' Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª
try:
    get_ipython().system('pip install -U -q libarchive')
    print("Ø§ÙƒØªÙ…Ù„Øª Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø© Ø¨Ø§ÙŠØ«ÙˆÙ† 'libarchive'.")
except Exception as e:
    print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø© Ø¨Ø§ÙŠØ«ÙˆÙ† 'libarchive' Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pip: {e}")
print("-" * 30)

print("Ø§Ù„Ø®Ø·ÙˆØ© 4: Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…ÙƒØªØ¨Ø© libarchive ÙÙŠ Ø¨Ø§ÙŠØ«ÙˆÙ†...")
try:
    import libarchive
    print("\nğŸ‰ Ù†Ø¬Ø§Ø­!")
    print("ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…ÙƒØªØ¨Ø© 'libarchive' Ø¨Ù†Ø¬Ø§Ø­.")
    print("ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ.")
    # ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© ÙƒÙˆØ¯ Ø¨Ø³ÙŠØ· ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ù…ÙƒØªØ¨Ø© Ù‡Ù†Ø§ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª
    # Ù…Ø«Ø§Ù„:
    # print(f"Ø¥ØµØ¯Ø§Ø± libarchive Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {libarchive.version_details()}")
except ModuleNotFoundError:
    print("\nâŒ Ø®Ø·Ø£: ÙØ´Ù„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…ÙƒØªØ¨Ø© 'libarchive'.")
    print("Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ ØºØ§Ù„Ø¨Ù‹Ø§ Ø£Ù† Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© (ØªØ«Ø¨ÙŠØª libarchive-dev Ø£Ùˆ pip install libarchive) Ù„Ù… ØªÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")
    print("ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø£ÙŠ Ø±Ø³Ø§Ø¦Ù„ Ø®Ø·Ø£ Ø¸Ù‡Ø±Øª ÙÙŠ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø£Ø¹Ù„Ø§Ù‡.")
    print("Ø¥Ø°Ø§ Ø¸Ù‡Ø± Ø®Ø·Ø£ '404 Not Found' ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ© 2ØŒ ÙÙ‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù† 'apt-get update' Ø±Ø¨Ù…Ø§ Ù„Ù… ÙŠÙ†Ø¬Ø­ Ø£Ùˆ Ø£Ù† Ø§Ù„Ø­Ø²Ù…Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©.")
except Exception as e:
    print(f"\nâŒ Ø®Ø·Ø£ Ø¢Ø®Ø± ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªÙŠØ±Ø§Ø¯ 'libarchive': {e}")

print("-" * 30)
print("Ø§ÙƒØªÙ…Ù„ ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª.")

pip install nest_asyncio

!pip install telethon PyMuPDF python-docx python-pptx nest_asyncio

!pip install PyMuPDF

!pip install -U telethon

from telethon.tl.types import PeerUser, MessageMediaPhoto, MessageMediaDocument
# ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ MessageMediaVideo, MessageMediaVoice, MessageMediaAudio Ù‡Ù†Ø§

!pip install PyMuPDF

pip install -U telethon PyMuPDF python-docx python-pptx nest_asyncio

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø£ÙˆÙ„: Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ© (Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ logging) ---
# ----------------------------------------------------------------------------------
import os
import asyncio
import math
# --- ØªØ£ÙƒØ¯ Ù…Ù† ØªØ«Ø¨ÙŠØª Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ ÙÙŠ Colab Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…: ---
# --- !pip install -U telethon PyMuPDF python-docx python-pptx nest_asyncio ---
import fitz  # PyMuPDF
import docx
import pptx
# -----------------------------------------------------------
from telethon import TelegramClient, events
from telethon.sessions import StringSession

# --- Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø­Ù„ Ù†Ù‡Ø§Ø¦ÙŠ ÙˆØ´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ ---
# Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªÙŠ Ù†Ø­ØªØ§Ø¬Ù‡Ø§
error_classes = [
    'UserIsBlocked',
    'PeerIdInvalid',
    'MessageDeleteForbiddenError',
    'FileReferenceExpiredError'
]

# Ø³ÙŠÙ‚ÙˆÙ… Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙƒÙ„ Ø®Ø·Ø£ØŒ ÙˆØ¥Ø°Ø§ ÙØ´Ù„ØŒ Ø³ÙŠÙ‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ÙØ¦Ø© ÙˆÙ‡Ù…ÙŠØ© Ù„Ù‡.
for error_name in error_classes:
    try:
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø£Ø­Ø¯Ø«
        exec(f"from telethon.errors import {error_name}")
    except ImportError:
        try:
            # Ø¥Ø°Ø§ ÙØ´Ù„ØŒ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø£Ù‚Ø¯Ù…
            exec(f"from telethon.errors.rpcerrorlist import {error_name}")
        except ImportError:
            # Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ„ Ø´ÙŠØ¡ØŒ Ø£Ù†Ø´Ø¦ ÙØ¦Ø© ÙˆÙ‡Ù…ÙŠØ©
            globals()[error_name] = type(error_name, (Exception,), {})
            print(f"WARNING: '{error_name}' not found. Created a dummy class. It's highly recommended to update Telethon with '!pip install -U telethon' and restart the runtime.")
# --- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ---

from telethon.tl.types import PeerUser, MessageMediaPhoto, MessageMediaDocument, User
from telethon.tl import types as telethon_types # Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… types.DocumentAttributeAudio
from datetime import datetime, timedelta
import sys
import traceback
import glob
import nest_asyncio
import logging

# ØªØ·Ø¨ÙŠÙ‚ nest_asyncio
try:
    nest_asyncio.apply()
    print("nest_asyncio applied for IPython/Jupyter environment.")
except RuntimeError as e:
    if "cannot apply nest_asyncio" in str(e).lower():
        print(f"nest_asyncio may have already been applied: {e}")
    else:
        raise

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ (Logging Setup)
LOG_FILENAME = 'bot_activity.log'
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILENAME, mode='a', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('MyTelegramBot')

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø«Ø§Ù†ÙŠ: Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© ÙˆØ§Ù„Ø«ÙˆØ§Ø¨Øª ---
# ----------------------------------------------------------------------------------
API_ID = 16504919  # Ø§Ø³ØªØ¨Ø¯Ù„ Ø¨Ù€ API_ID Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
API_HASH = 'e9ddbc4aa70093979dcc2d20153fba08'  # Ø§Ø³ØªØ¨Ø¯Ù„ Ø¨Ù€ API_HASH Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
SESSION_STRING = '1ApWapzMBuwejlRF09skSWxYWFj0MbNtZ4NkoYlqgaBviKXmI-3-QroMfcOZ26AYle1-eklyLTaeoJD6QWxIhNDnxWapeYaqRKknoGoTtPvJ9e7UivDk2cTPZ2MxCMfH6qW7OBUiPIlxJA-kzIRMRfVzydjM-zWI0N4h5FS9_Sx1aeCMpBlOi2yqzius9EiXdk4aEnI9aWndxCEx_a_SuyPN5ljTgFK8JB-oGKwQ5_2eD1r2NI0SOZ9dUGLhrtU3Z62SlvnAWgWEAVbCDuPMm9svEi9x5LkhIiIEXGuGWIyFv7FtJfh_1Uj0VwziT73ejai1akINyxy84eHMltF8tZsXuVkHCMTU=' # <--- Ù‡Ø§Ù… Ø¬Ø¯Ø§Ù‹: Ø¶Ø¹ Ø³Ù„Ø³Ù„Ø© Ø¬Ù„Ø³ØªÙƒ Ù‡Ù†Ø§

client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)

NOTIFICATION_CHAT = -1002356701524
is_sleeping = False
user_prices = {} # Ø³ÙŠØ®Ø²Ù† Ø§Ù„Ø¢Ù†: user_prices[user_id][msg_id] = (base_price, cover_price, pages)
user_status_messages = {}
user_last_interaction_time = {}
ignored_users = set()
bot_id = None
global_daily_total_collected = 0
bot_start_time = None
daily_report_task = None
user_confirmation_state = {}
users_interacted_while_sleeping = {}

# --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ---
custom_auto_reply_mode = False
custom_auto_reply_message = "ØµØ§Ø­Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ØªÙˆÙØ± Ø­Ø§Ù„ÙŠÙ‹Ø§. Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ Ù„Ø§Ø­Ù‚Ù‹Ø§."
stats_confirmed_orders = 0
stats_rejected_orders = 0
stats_total_confirmed_files = 0
stats_interacted_users = set()
# --------------------------------

PRICE_PER_PAGE_LT50 = 50
PRICE_PER_PAGE_GTE50 = 40
COVER_BINDING_COST = 500

DEFAULT_WELCOME_MESSAGE = "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ {user_name} ÙÙŠ Ø¨ÙˆØª Ø­Ø³Ø§Ø¨ Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©! Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ù„Ù PDF, DOCX, Ø£Ùˆ PPTX ÙˆØ³Ø£Ù‚ÙˆÙ… Ø¨Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ùƒ. ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù†ØµÙŠØ© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ."
WELCOME_MESSAGE_TEXT = DEFAULT_WELCOME_MESSAGE
WELCOME_COOLDOWN = timedelta(hours=12)
DEFAULT_OWNER_ALERT_MESSAGE = "ğŸ”” ØªÙ†Ø¨ÙŠÙ‡ Ù„Ù„Ù…Ø§Ù„Ùƒ: ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ù…Ù„Ù/Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ù…Ø³ØªØ®Ø¯Ù…."
OWNER_ALERT_MESSAGE_TEXT = DEFAULT_OWNER_ALERT_MESSAGE
APOLOGY_MESSAGE_AFTER_PRICE_WHEN_SLEEPING = "\n\nğŸ“ ØªÙ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø±. ØµØ§Ø­Ø¨ Ø§Ù„Ù…ÙƒØªØ¨Ø© ØºÙŠØ± Ù…ØªÙˆÙØ± Ø­Ø§Ù„ÙŠÙ‹Ø§ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ Ø¹ÙˆØ¯ØªÙ‡ Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø·Ù„Ø¨Ùƒ."
WAITING_MESSAGE_NORMAL = "Ø´ÙƒØ±Ù‹Ø§ Ù„Ø±Ø³Ø§Ù„ØªÙƒ. Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ Ø¨Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª Ù…Ù…ÙƒÙ†."
CALCULATING_MESSAGE = "â³ Ø¬Ø§Ø± Ø§Ø­ØªØ³Ø§Ø¨... ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±."
FILE_TYPE_ERROR_MESSAGE = "âš ï¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù PDFØŒ DOCXØŒ Ø£Ùˆ PPTX ÙÙ‚Ø·. Ø§Ù„ØµÙˆØ± ÙˆØ§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø±Ù‰ Ù…Ù† Ø§Ù„Ù…Ù„ÙØ§Øª ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø±."
COUNT_PAGES_ERROR_MESSAGE = "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù: Ù„Ù… ÙŠØªÙ…ÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø±Ø§Ø¡Ø© Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø£Ùˆ Ø§Ù„Ù…Ù„Ù ØªØ§Ù„Ù."
PROCESSING_ERROR_MESSAGE = "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
MUTE_CONFIRMATION_FOR_OWNER = "âœ… ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_id}` Ø¨Ù†Ø¬Ø§Ø­. Ù„Ù† ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ø¦Ù„Ù‡."
UNMUTE_CONFIRMATION_FOR_OWNER = "âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_id}` Ø¨Ù†Ø¬Ø§Ø­. Ø³ÙŠØ¹ÙˆØ¯ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ø¦Ù„Ù‡."
USER_ALREADY_IGNORED_OWNER = "âš ï¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_id}` Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ¬Ø§Ù‡Ù„."
USER_NOT_IGNORED_OWNER = "âš ï¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_id}` Ù„ÙŠØ³ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ¬Ø§Ù‡Ù„ Ø£ØµÙ„Ø§Ù‹."
TARGET_USER_NOT_FOUND_OWNER = "âŒ Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ù…Ø± Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ø£Ùˆ Ø¨ØªØ¶Ù…ÙŠÙ† ID Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ù…Ø± `.Ø³Ù…Ø§Ø­ <ID>` / `.Ø§Ù„ØºØ§Ø¡ <ID>` ÙÙŠ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª."
DAILY_REPORT_MESSAGE_TEMPLATE = "ğŸ“Š Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ ({date}):\nØ§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù„Ù…Ø¨Ø§Ù„Øº Ø§Ù„ØªÙŠ ØªÙ… Ø¹Ø±Ø¶Ù‡Ø§ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (ÙˆØªÙ… ØªØ£ÙƒÙŠØ¯Ù‡Ø§) Ø®Ù„Ø§Ù„ Ø§Ù„Ù€ 24 Ø³Ø§Ø¹Ø© Ø§Ù„Ù…Ø§Ø¶ÙŠØ©: {total} Ø¯ÙŠÙ†Ø§Ø±."
PRICE_UPDATE_SUCCESS_TEMPLATE = "âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« `{price_name}` Ø¥Ù„Ù‰ {new_price} Ø¯ÙŠÙ†Ø§Ø±."
PRICE_UPDATE_ERROR = "âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø±. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø£Ù…Ø± ÙˆØ§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¹Ø¯Ø¯ÙŠØ© (Ù…Ø«Ø§Ù„: `.Øª1 60`)."
PRICE_UPDATE_INVALID_VALUE = "âŒ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ØºÙŠØ± ØµØ­ÙŠØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù‚ÙŠÙ…Ø© Ø¹Ø¯Ø¯ÙŠØ© ØµØ­ÙŠØ­Ø© (Ù…Ø«Ø§Ù„: `.Øª1 60`)."
CUMULATIVE_TOTAL_MESSAGE_TEMPLATE = ("ğŸ“Š ×”×Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†:\n"
                                   "Ø¨Ø¯ÙˆÙ† Ø¬Ù„Ø§Ø¯: {total_base} Ø¯ÙŠÙ†Ø§Ø±\n"
                                   "Ù…Ø¹ Ø¬Ù„Ø§Ø¯: {total_cover} Ø¯ÙŠÙ†Ø§Ø±")
OWNER_REQUESTED_PRICE_INFO_TEMPLATE = ("ğŸ“„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ³Ø¹ÙŠØ± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·Ù„Ø¨Ùƒ):\n"
                                     "ğŸ“– Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª (Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³Ø¹Ø±Ø©): {total_pages}\n"
                                     "ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (Ø¨Ø¯ÙˆÙ† Ø¬Ù„Ø§Ø¯): {total_base} Ø¯ÙŠÙ†Ø§Ø±\n"
                                     "ğŸ·ï¸ Ø§Ù„Ø³Ø¹Ø± Ù…Ø¹ Ø¬Ù„Ø§Ø¯: {total_cover} Ø¯ÙŠÙ†Ø§Ø±")
CONFIRMATION_PROMPT_MESSAGE = "\n\nğŸ¤” Ù‡Ù„ Ø£Ù†Øª Ù…ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø³Ø­Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¹Ø±ØŸ\nØ£Ø¬Ø¨ Ø¨Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù…Ø«Ù„ `Ù†Ø¹Ù…`/`Ù…ÙˆØ§ÙÙ‚` Ø£Ùˆ `Ù„Ø§`/`Ø§Ø±ÙØ¶`."
ORDER_CONFIRMED_AWAKE_MESSAGE = "âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨Ùƒ ÙˆØ¬Ø§Ø±Ù Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡. Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ù‹Ø§."
ORDER_CONFIRMED_SLEEPING_MESSAGE = "âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø·Ù„Ø¨Ùƒ. Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø¹Ù†Ø¯ Ø¹ÙˆØ¯Ø© ØµØ§Ø­Ø¨ Ø§Ù„Ù…ÙƒØªØ¨Ø© Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªÙØ§ØµÙŠÙ„."
CONFIRMATION_REJECTED_ASK_REASON_MESSAGE = "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨. Ø¥Ø°Ø§ Ø£Ù…ÙƒÙ†ØŒ ÙŠØ±Ø¬Ù‰ Ø°ÙƒØ± Ø³Ø¨Ø¨ Ø§Ù„Ø±ÙØ¶ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)."
PROGRESS_MESSAGE_SAVE_MEDIA = "Ø¯Ù‚ÙŠÙ‚Ø© Ù†Øª Ø¶Ø¹ÙŠÙ Ø®Ù„ ØªÙØªØ­ â¤ï¸"
FILE_PROCESSED_ADD_TO_ORDER_PROMPT_TOTAL = (
    "\n\nâœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ø·Ù„Ø¨Ùƒ. Ø£Ø±Ø³Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù†ØµÙŠØ© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ ÙˆØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø·Ù„Ø¨."
)
ORDER_COMPLETION_MESSAGE_USER = (
    "Ø¹Ø²ÙŠØ²ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­.\n"
    "ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªÙ„Ø§Ù…Ù‡ Ø£Ùˆ Ø·Ù„Ø¨ ØªÙˆØµÙŠÙ„ Ù…Ø¹ Ø°ÙƒØ± Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:\n"
    "- Ø§Ù„Ø§Ø³Ù…:\n"
    "- Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ:\n"
    "- Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø¯Ø§Ù„Ø©:\n\n"
    "Ø´ÙƒØ±Ù‹Ø§ Ù„Ø§Ø®ØªÙŠØ§Ø±Ù†Ø§."
)
UNMUTE_ALL_CONFIRMATION_OWNER = "âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­."
UNMUTE_ALL_NO_IGNORED_OWNER = "â„¹ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ¬Ø§Ù‡Ù„ Ø­Ø§Ù„ÙŠÙ‹Ø§."

KEYWORDS_CONFIRM = ["Ù†Ø¹Ù…", "Ø§ÙŠ", "Ø£Ø¬Ù„", "Ù…ÙˆØ§ÙÙ‚", "Ù…ÙˆØ§ÙÙ‚Ø©", "yes", "ok", "confirm", "yep", "yeah", "ØªÙ…Ø§Ù…", "Ø§ÙˆÙƒÙŠ", "ÙˆÙƒ", "Ø§ÙˆÙƒ", "ØªÙ…"]
KEYWORDS_CANCEL = ["Ù„Ø§", "ÙƒÙ„Ø§", "Ø§Ø±ÙØ¶", "no", "cancel", "nope", "Ø§Ù„ØºØ§Ø¡"]

MENU_HEADER = "ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆØ§Ù…Ø± Ø¨ÙˆØª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©:\n"
MAIN_MENU_OPTIONS = {
    "1": "Ø£ÙˆØ§Ù…Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª",
    "2": "Ø£ÙˆØ§Ù…Ø± ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±",
    "3": "Ø£ÙˆØ§Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†",
    "4": "Ø£ÙˆØ§Ù…Ø± Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆØ¥Ø­ØµØ§Ø¦ÙŠØ§Øª",
    "5": "Ø£Ù…Ø± Ø­ÙØ¸ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· (.Ø­Ù„Ùˆ)",
    "6": "Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©"
}

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ---
# ----------------------------------------------------------------------------------
def get_main_menu_text():
    text = MENU_HEADER
    for key, value in MAIN_MENU_OPTIONS.items():
        text += f"  `.Ù…{key}` - {value}\n"
    text += "\nØ£Ø±Ø³Ù„ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹ Ø§Ù„Ø±Ù‚Ù… Ù„Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„ (Ù…Ø«Ø§Ù„: `.Ù…1`)"
    return text

def get_status_commands_text():
    return (
        "ğŸ”¹ Ø£ÙˆØ§Ù…Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª (ØªÙØ³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª 'Saved Messages'):\n"
        "  `.Ù†Ø§ÙŠÙ…` - ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… (ØªÙ†Ø¨ÙŠÙ‡Ø§Øª ÙÙ‚Ø·).\n"
        "  `.ÙƒØ§Ø¹Ø¯` - ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø³ØªØ¹Ø¯Ø§Ø¯ (ÙŠÙ„ØºÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… ÙˆØ§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ).\n"
        "  `.Ù…` - Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø£ÙˆØ§Ù…Ø±.\n"
        "  `.ØªÙØ¹ÙŠÙ„` - Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆÙ…Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„.\n"
        "  `.ÙØ­Øµ` - Ø¥Ø¬Ø±Ø§Ø¡ ÙØ­Øµ Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¹Ø§Ù…Ø©.\n"
        "  `.ØªÙ† <Ø±Ø³Ø§Ù„Ø©>` - ØªØºÙŠÙŠØ± Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ù„Ù„Ù…Ø§Ù„Ùƒ.\n"
        "  `.ØªØ± <Ø±Ø³Ø§Ù„Ø©>` - ØªØºÙŠÙŠØ± Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ø§Ø³ØªØ®Ø¯Ù… {user_name}).\n"
        "\nÙ„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: `.Ù…`"
    )

def get_prices_commands_text():
    return (
        f"ğŸ’° Ø£ÙˆØ§Ù…Ø± ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± (Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø£Ù‚ÙˆØ§Ø³ []):\n"
        f"  `.Øª1 <Ù‚ÙŠÙ…Ø©>` - Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (< 50) [{PRICE_PER_PAGE_LT50}]\n"
        f"  `.Øª2 <Ù‚ÙŠÙ…Ø©>` - Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (>= 50) [{PRICE_PER_PAGE_GTE50}]\n"
        f"  `.Øª3 <Ù‚ÙŠÙ…Ø©>` - ØªÙƒÙ„ÙØ© Ø§Ù„Ø¬Ù„Ø§Ø¯ [{COVER_BINDING_COST}]\n"
        "\nÙ„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: `.Ù…`"
    )

def get_users_commands_text():
    return (
        "ğŸ‘¥ Ø£ÙˆØ§Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ):\n"
        "  * ÙÙŠ **Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø®Ø§ØµØ© Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**:\n"
        "    `.Ø³Ù…Ø§Ø­` (Ø£Ùˆ Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…) - Ù„ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ.\n"
        "    `.Ø³Ù…Ø§Ø­ <user_ID>` - Ù„ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¨Ø§Ù„Ù€ ID.\n"
        "    `.Ø§Ù„ØºØ§Ø¡` (Ø£Ùˆ Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…) - Ù„Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ.\n"
        "    `.Ø§Ù„ØºØ§Ø¡ <user_ID>` - Ù„Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¨Ø§Ù„Ù€ ID.\n"
        "    `.Ø¹Ø±Ø¶` - Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±Ø³Ù„Ø© (ÙŠÙØ±Ø³Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ù…Ø¹ Ø³Ø¤Ø§Ù„ ØªØ£ÙƒÙŠØ¯).\n"
        "    `.Ø³` - Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª (ÙŠÙØ±Ø³Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ø¨Ø¯ÙˆÙ† Ø³Ø¤Ø§Ù„ ØªØ£ÙƒÙŠØ¯).\n"
        "    `.Ùƒ` - Ù„Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù….\n"
        "  * ÙÙŠ **Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª ('me')**:\n"
        "    `.Ø³Ù…Ø§Ø­ <user_ID>` - Ù„ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¨Ø§Ù„Ù€ ID.\n"
        "    `.Ø§Ù„ØºØ§Ø¡ <user_ID>` - Ù„Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¨Ø§Ù„Ù€ ID.\n"
        "    `.Ø§Ù„ØºØ§Ø¡Ùƒ` - Ù„Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.\n"
        "\nÙ„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: `.Ù…`"
    )

def get_advanced_commands_text():
    return (
        "âš™ï¸ Ø£ÙˆØ§Ù…Ø± Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆØ¥Ø­ØµØ§Ø¦ÙŠØ§Øª:\n"
        "  `.ØªÙ†Ø§ÙŠÙ… <Ù†Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø©>` - ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ©. Ù„Ù„Ø¥Ù„ØºØ§Ø¡ Ø§Ø³ØªØ®Ø¯Ù… `.ÙƒØ§Ø¹Ø¯`.\n"
        "  `.Ø§Ø°Ø§Ø¹Ø©` (Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©) - Ø¨Ø« Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ØªÙØ§Ø¹Ù„ÙˆØ§ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØª.\n"
        "  `.Ø³Ø¬Ù„` - Ø¹Ø±Ø¶ ØªÙ‚Ø±ÙŠØ± ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§ØªØŒ Ø§Ù„Ø±ÙØ¶ØŒ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª) Ø«Ù… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†Ù‡.\n"
        "\nÙ„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: `.Ù…`"
    )

def get_notes_text():
    return (
        "ğŸ“ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:\n"
        "  - Ø§Ù„Ø¨ÙˆØª ÙŠÙ‚ÙˆÙ… Ø¨Ø­ÙØ¸ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¯Ù…ÙŠØ± ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙÙŠ Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.\n"
        "  - Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (ÙˆÙ„ÙŠØ³ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ø£Ø®Ø±Ù‰).\n"
        "  - Ø¨Ø¹Ø¯ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠØŒ Ø³ÙŠØ³Ø£Ù„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØªØ£ÙƒÙŠØ¯ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø³Ø­Ø¨.\n"
        "  - Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ù…Ù„Ù Ø³ÙŠØ¤Ø¯ÙŠ Ø¥Ù„Ù‰ Ø®ØµÙ… Ø³Ø¹Ø±Ù‡ ÙˆØ¹Ø¯Ø¯ ØµÙØ­Ø§ØªÙ‡ Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ø§Ù„Ù…Ø®Ø²Ù†.\n"
        "  - Ù‡Ù†Ø§Ùƒ ØªÙ‚Ø±ÙŠØ± ÙŠÙˆÙ…ÙŠ Ù„Ù„Ù…Ø¨Ø§Ù„Øº Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„Ù‡ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª 'Saved Messages'.\n"
        "  - Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†ØŒ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ¬Ø§Ù‡Ù„ØŒ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø³Ø¬Ù„) Ù…Ø¤Ù‚ØªØ© ÙˆØªÙÙÙ‚Ø¯ Ø¹Ù†Ø¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª.\n"
        "\nÙ„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: `.Ù…`"
    )

def get_save_command_text():
    return (
        "ğŸ“¥ Ø£Ù…Ø± Ø­ÙØ¸ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· (`.Ø­Ù„Ùˆ`):\n"
        "  - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ù…Ø± `.Ø­Ù„Ùˆ` **Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©** ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ³Ø§Ø¦Ø· (ØµÙˆØ±Ø©ØŒ ÙÙŠØ¯ÙŠÙˆØŒ Ù…Ù„ÙØŒ Ø¥Ù„Ø®).\n"
        "  - Ø³ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨ÙˆØª Ø¨Ø­ÙØ¸ Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· ÙƒÙ€ **Ù…Ø³ØªÙ†Ø¯ (Ù…Ù„Ù)** ÙÙŠ Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© ('me').\n"
        "  - Ù…ÙÙŠØ¯ Ø¨Ø´ÙƒÙ„ Ø®Ø§Øµ Ù„Ù„ÙˆØ³Ø§Ø¦Ø· Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±ØŒ Ø£Ùˆ Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ Ù…Ù„ÙØ§Øª.\n"
        "  - Ø³ÙŠØªÙ… ØªØ¶Ù…ÙŠÙ† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„ÙˆØ³Ø§Ø¦Ø· ÙÙŠ ØªØ¹Ù„ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­ÙÙˆØ¸.\n"
        "\nÙ„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: `.Ù…`"
    )

def round_up_to_250(x): return int(math.ceil(x / 250.0) * 250)

def calculate_price(pages_count):
    price_per_page = PRICE_PER_PAGE_LT50 if pages_count < 50 else PRICE_PER_PAGE_GTE50
    base_p = pages_count * price_per_page
    return round_up_to_250(base_p), round_up_to_250(base_p + COVER_BINDING_COST)

async def run_sync_in_thread(func, *args, **kwargs): return await asyncio.to_thread(func, *args, **kwargs)

async def count_pages_for_document(file_path, ext):
    try:
        if ext == '.pdf':
            doc = await run_sync_in_thread(fitz.open, file_path); pages = await run_sync_in_thread(lambda d: len(d), doc); await run_sync_in_thread(doc.close); return pages
        elif ext == '.docx':
            doc = await run_sync_in_thread(docx.Document, file_path)
            # ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ù„Ù„Ù€ DOCX ØºÙŠØ± Ø¯Ù‚ÙŠÙ‚ØŒ Ù‡Ø°Ù‡ Ù…Ø¬Ø±Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø³ÙŠØ·Ø©
            return doc.sections[0].page_height.inches * len(doc.sections) if doc.sections else 1
        elif ext == '.pptx':
            pres = await run_sync_in_thread(pptx.Presentation, file_path); slides = await run_sync_in_thread(lambda p: list(p.slides), pres); return len(slides)
        logger.warning(f"Unsupported extension '{ext}' for page counting: {file_path}"); return 0
    except Exception as e: logger.error(f"Error counting pages for {file_path} ({ext}): {e}", exc_info=True); return 0

async def send_cumulative_total(user_id, event_for_reply, ask_confirmation=True, custom_template=None, total_pages_info=None):
    global user_prices, user_confirmation_state, is_sleeping
    chat_id = event_for_reply.chat_id
    user_prices_dict = user_prices.get(user_id, {})
    total_base = sum(p[0] for p in user_prices_dict.values())
    total_cover = sum(p[1] for p in user_prices_dict.values())

    if total_pages_info is None and user_prices_dict:
        calculated_pages = sum(p[2] for p in user_prices_dict.values() if len(p) == 3)
        total_pages_info = calculated_pages if calculated_pages > 0 else "ØºÙŠØ± Ù…ØªØ§Ø­"

    sent_total_msg_obj = None

    if total_base > 0 or total_cover > 0:
        if custom_template:
            reply_text = custom_template.format(total_pages=total_pages_info or "ØºÙŠØ± Ù…ØªØ§Ø­", total_base=total_base, total_cover=total_cover)
        else:
            reply_text = CUMULATIVE_TOTAL_MESSAGE_TEMPLATE.format(total_base=total_base, total_cover=total_cover)

        if is_sleeping and ask_confirmation:
             reply_text += APOLOGY_MESSAGE_AFTER_PRICE_WHEN_SLEEPING

        try:
            reply_to_id = event_for_reply.id
            if hasattr(event_for_reply, 'message') and event_for_reply.message == ".Ø³":
                sent_total_msg_obj = await client.send_message(chat_id, reply_text)
            else:
                sent_total_msg_obj = await event_for_reply.respond(reply_text)

            logger.info(f"Sent cumulative total (Base: {total_base}, Pages: {total_pages_info or 'N/A'}) for user {user_id}. Ask confirm: {ask_confirmation}")

            if ask_confirmation and sent_total_msg_obj:
                conf_q_msg_obj = await client.send_message(chat_id, CONFIRMATION_PROMPT_MESSAGE, reply_to=sent_total_msg_obj.id)
                user_confirmation_state[user_id] = {'message_id_of_question': conf_q_msg_obj.id, 'original_total_message_id': sent_total_msg_obj.id, 'time_asked': datetime.now()}
                logger.info(f"Asked user {user_id} for order confirmation (Q_ID: {conf_q_msg_obj.id}).")
        except Exception as e: logger.error(f"Error in send_cumulative_total for user {user_id}: {e}", exc_info=True)
    else:
        no_price_msg = "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ù…Ø³Ø¹Ø±Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¹Ø¯." if custom_template else "Ù„Ù… ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„ÙØ§Øª Ù„Ø­Ø³Ø§Ø¨Ù‡Ø§ Ø¨Ø¹Ø¯."
        await event_for_reply.respond(no_price_msg)
        logger.info(f"No cumulative total to send for user {user_id} (custom_template used: {bool(custom_template)}).")

async def send_notification(message_text_param=None, parse_mode=None):
    global bot_id, OWNER_ALERT_MESSAGE_TEXT, NOTIFICATION_CHAT
    final_message_to_send = message_text_param if message_text_param else OWNER_ALERT_MESSAGE_TEXT
    logger.info(f"Attempting to send notification to '{NOTIFICATION_CHAT}': {final_message_to_send[:100]}...")
    if bot_id is None:
        try:
            if client.is_connected(): me_check = await client.get_me(); bot_id = me_check.id if me_check else None
            if bot_id: logger.info(f"Acquired bot_id {bot_id} for notification.")
            else: logger.error("Failed to acquire bot_id for notification."); return
        except Exception as e_me: logger.error(f"Exception acquiring bot_id: {e_me}", exc_info=True); return
    try:
        await client.send_message(NOTIFICATION_CHAT, final_message_to_send, parse_mode=parse_mode)
        logger.info(f"Notification sent to chat: {NOTIFICATION_CHAT}.")
    except ValueError as ve: logger.error(f"ValueError sending to '{NOTIFICATION_CHAT}': {ve}. Invalid ID/bot access?", exc_info=True)
    except Exception as e: logger.error(f"Error sending to '{NOTIFICATION_CHAT}': {e}", exc_info=True)

async def report_daily_total():
    global global_daily_total_collected, bot_id
    logger.info("Daily report task waiting for bot_id...")
    while bot_id is None: await asyncio.sleep(5)
    logger.info("Daily report task started.")
    while True:
        await asyncio.sleep(24 * 60 * 60)
        logger.info("Attempting daily report...")
        current_total_for_report = global_daily_total_collected
        if current_total_for_report > 0:
            r_date = datetime.now().strftime("%Y-%m-%d"); r_text = DAILY_REPORT_MESSAGE_TEMPLATE.format(date=r_date, total=current_total_for_report)
            try:
                await client.send_message('me', r_text)
                logger.info(f"Daily report sent: {current_total_for_report} IQD.")
                global_daily_total_collected = 0
            except Exception as e:
                logger.error(f"Failed to send daily report: {e}. Total {current_total_for_report} will be carried over.", exc_info=True)
        else:
            logger.info("No total collected (confirmed orders) in the last 24 hours. Skipping daily report.")


# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹: Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø§Ù„Ùƒ ---
# ----------------------------------------------------------------------------------
@client.on(events.NewMessage(chats='me', pattern='^\.Ù†Ø§ÙŠÙ…$', outgoing=True))
async def go_sleep(event):
    if bot_id is None: logger.error("Cannot process .Ù†Ø§ÙŠÙ…: bot_id is None."); return
    global is_sleeping; is_sleeping = True
    logger.info("Bot state: Sleeping (owner cmd)."); await event.reply("âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ….")

@client.on(events.NewMessage(chats='me', pattern='^\.ÙƒØ§Ø¹Ø¯$', outgoing=True))
async def wake_up(event):
    if bot_id is None: logger.error("Cannot process .ÙƒØ§Ø¹Ø¯: bot_id is None."); return
    global is_sleeping, users_interacted_while_sleeping, custom_auto_reply_mode
    prev_sleeping = is_sleeping; is_sleeping = False
    prev_auto_reply = custom_auto_reply_mode; custom_auto_reply_mode = False
    logger.info("Bot state: Awake (owner cmd). Disabled sleep and auto-reply modes.")

    resp_parts = ["âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø³ØªØ¹Ø¯Ø§Ø¯." ]
    if prev_auto_reply: resp_parts.append("âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.")

    if prev_sleeping and users_interacted_while_sleeping:
        logger.info(f"Reporting {len(users_interacted_while_sleeping)} users interacted while sleeping.")
        u_list_msg = "\n\nâ„¹ï¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù…ØªÙØ§Ø¹Ù„ÙˆÙ† Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù†ÙˆÙ… (Ø¢Ø®Ø± ØªÙØ§Ø¹Ù„):\n"
        sorted_inters = sorted(users_interacted_while_sleeping.items(), key=lambda item: item[1]['interaction_time'], reverse=True)
        for uid, data in sorted_inters:
            u_list_msg += f"- {data.get('name', f'ID: {uid}')} ({data.get('type', 'ØªÙØ§Ø¹Ù„')} ÙÙŠ {data.get('interaction_time').strftime('%H:%M')})\n"
        if sorted_inters: resp_parts.append(u_list_msg)
        else: resp_parts.append("\n\nâ„¹ï¸ Ù„Ù… ØªØ³Ø¬Ù„ ØªÙØ§Ø¹Ù„Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù†ÙˆÙ….")
        users_interacted_while_sleeping.clear()
    await event.reply("\n".join(resp_parts))

@client.on(events.NewMessage(pattern=r'^\.Ù…(\d*)$', outgoing=True, func=lambda e: e.chat_id == bot_id))
async def list_commands_numbered_menu(event):
    if bot_id is None: return
    submenu_number_str = event.pattern_match.group(1)
    reply_text = ""
    if not submenu_number_str: reply_text = get_main_menu_text()
    else:
        if submenu_number_str == "1": reply_text = get_status_commands_text()
        elif submenu_number_str == "2": reply_text = get_prices_commands_text()
        elif submenu_number_str == "3": reply_text = get_users_commands_text()
        elif submenu_number_str == "4": reply_text = get_advanced_commands_text()
        elif submenu_number_str == "5": reply_text = get_save_command_text()
        elif submenu_number_str == "6": reply_text = get_notes_text()
        else: reply_text = "Ø±Ù‚Ù… Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© ØºÙŠØ± ØµØ§Ù„Ø­. Ø£Ø±Ø³Ù„ `.Ù…` Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª."
    await event.reply(reply_text)

@client.on(events.NewMessage(chats='me', pattern=r'^\.ØªÙØ¹ÙŠÙ„$', outgoing=True))
async def handle_status_command_owner(event):
    if bot_id is None: return
    global is_sleeping, bot_start_time, user_last_interaction_time, user_prices, ignored_users, custom_auto_reply_mode
    status_msg = "âœ… Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: "
    if custom_auto_reply_mode: status_msg += f"Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ (Ø±Ø³Ø§Ù„Ø©: '{custom_auto_reply_message[:20]}...')"
    elif is_sleeping: status_msg += "Ù†Ø§ÙŠÙ…"
    else: status_msg += "ÙƒØ§Ø¹Ø¯ (Ù…Ø³ØªØ¹Ø¯)"
    status_msg += "\n"

    if bot_start_time:
        uptime = datetime.now() - bot_start_time; days, rem = uptime.days, uptime.seconds
        h, rem = divmod(rem, 3600); m, s = divmod(rem, 60)
        status_msg += f"â° Ù…Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„: {days} ÙŠ, {h} Ø³, {m} Ø¯, {s} Ø«\n"
    else: status_msg += "â° Ù…Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„: ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©\n"
    status_msg += f"ğŸ‘¥ Ù…ØªÙØ§Ø¹Ù„ÙˆÙ† (Ø¹Ø§Ù…): {len([k for k in user_last_interaction_time if k.startswith('general_')])}\n"
    status_msg += f"ğŸ“Š Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø¨Ø£Ø³Ø¹Ø§Ø± Ù…Ø³Ø¬Ù„Ø©: {len(user_prices)}\n"
    status_msg += f"ğŸš« Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù…ØªØ¬Ø§Ù‡Ù„ÙˆÙ†: {len(ignored_users)}\n"
    status_msg += f"ğŸ’° Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ø§Ù„Ù…ØªØ±Ø§ÙƒÙ… (Ø§Ù„Ù…Ø¤ÙƒØ¯): {global_daily_total_collected} Ø¯ÙŠÙ†Ø§Ø±\n"
    logger.info("Owner requested bot status."); await event.reply(status_msg)

@client.on(events.NewMessage(chats='me', pattern='^\.ÙØ­Øµ$', outgoing=True))
async def handle_check_command_owner(event):
    if bot_id is None: return
    check_results = [f"ğŸ”— Ø§ØªØµØ§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„: {'Ø³Ù„ÙŠÙ…' if client.is_connected() else 'âŒ Ù…Ù‚Ø·ÙˆØ¹'}"]
    global daily_report_task
    if daily_report_task:
        status = "âš ï¸ Ù…Ù„ØºØ§Ø©" if daily_report_task.cancelled() else ("âŒ Ø§Ù†ØªÙ‡Øª" if daily_report_task.done() else "âœ… Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„")
        if daily_report_task.done() and daily_report_task.exception(): status += f" (Ø®Ø·Ø£: {daily_report_task.exception()!s:.50})"
        check_results.append(f"ğŸ“… ØªÙ‚Ø±ÙŠØ± ÙŠÙˆÙ…ÙŠ: {status}")
    else: check_results.append("âŒ ØªÙ‚Ø±ÙŠØ± ÙŠÙˆÙ…ÙŠ: Ù„Ù… ÙŠØ¨Ø¯Ø£")
    temp_dir = "temp"
    if os.path.exists(temp_dir):
        temp_files = [f for f in os.listdir(temp_dir) if os.path.isfile(os.path.join(temp_dir, f))]
        check_results.append(f"{'âš ï¸' if temp_files else 'âœ…'} Ù…Ù„ÙØ§Øª '{temp_dir}': {len(temp_files) if temp_files else 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}")
    else: check_results.append(f"âœ… Ù…Ø¬Ù„Ø¯ '{temp_dir}': ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
    response_text = "ğŸ“‹ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ÙØ­Øµ:\n" + "\n".join(check_results)
    logger.info("Owner requested bot health check."); await event.reply(response_text)

@client.on(events.NewMessage(chats='me', pattern=r'^\.ØªÙ†\s+(.+)', outgoing=True))
async def set_owner_alert_message(event):
    global OWNER_ALERT_MESSAGE_TEXT; new_alert = event.pattern_match.group(1).strip()
    if new_alert: OWNER_ALERT_MESSAGE_TEXT = new_alert; logger.info(f"Owner alert msg updated."); await event.reply(f"âœ… ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ù…Ø§Ù„Ùƒ:\n`{new_alert}`")
    else: await event.reply("âŒ ÙŠØ±Ø¬Ù‰ Ù†Øµ Ù„Ù„ØªÙ†Ø¨ÙŠÙ‡.")

@client.on(events.NewMessage(chats='me', pattern=r'^\.ØªØ±\s+(.+)', outgoing=True))
async def set_welcome_message_text(event):
    global WELCOME_MESSAGE_TEXT; new_welcome = event.pattern_match.group(1).strip()
    if new_welcome:
        if "{user_name}" not in new_welcome: await event.reply("âš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù„Ø§ ÙŠØ­ØªÙˆÙŠ `{user_name}`."); return
        WELCOME_MESSAGE_TEXT = new_welcome; logger.info(f"Welcome msg updated."); await event.reply(f"âœ… Ø§Ù„ØªØ±Ø­ÙŠØ¨:\n`{new_welcome}`")
    else: await event.reply("âŒ ÙŠØ±Ø¬Ù‰ Ù†Øµ Ù„Ù„ØªØ±Ø­ÙŠØ¨.")

@client.on(events.NewMessage(chats='me', pattern=r'^\.Øª([1-3])\s+(\d+)$', outgoing=True))
async def adjust_price_owner(event):
    try:
        price_type, new_val_str = int(event.pattern_match.group(1)), event.pattern_match.group(2)
        new_price = int(new_val_str)
        if new_price < 0: await event.reply(PRICE_UPDATE_INVALID_VALUE); return
        global PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST
        prices_map = {1: ("Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (< 50)", "PRICE_PER_PAGE_LT50"), 2: ("Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (>= 50)", "PRICE_PER_PAGE_GTE50"), 3: ("ØªÙƒÙ„ÙØ© Ø§Ù„Ø¬Ù„Ø§Ø¯", "COVER_BINDING_COST")}
        if price_type in prices_map:
            name, var_name = prices_map[price_type]; old_price = globals()[var_name]; globals()[var_name] = new_price
            logger.info(f"Price '{name}' updated by owner from {old_price} to {new_price}.")
            await event.reply(PRICE_UPDATE_SUCCESS_TEMPLATE.format(price_name=name, new_price=new_price))
        else: await event.reply(PRICE_UPDATE_ERROR)
    except ValueError: await event.reply(PRICE_UPDATE_INVALID_VALUE)
    except Exception as e: logger.error(f"Price adjust error: {e}", exc_info=True); await event.reply(PRICE_UPDATE_ERROR)

async def _perform_mute_unmute(target_user_id, event_for_reply_obj, action="mute"):
    global ignored_users, bot_id; is_mute = action == "mute"
    if target_user_id == bot_id:
        await event_for_reply_obj.respond("Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¬Ø§Ù‡Ù„/Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¨ÙˆØª Ù†ÙØ³Ù‡."); return
    if is_mute:
        if target_user_id in ignored_users: await event_for_reply_obj.respond(USER_ALREADY_IGNORED_OWNER.format(user_id=target_user_id))
        else: ignored_users.add(target_user_id); await event_for_reply_obj.respond(MUTE_CONFIRMATION_FOR_OWNER.format(user_id=target_user_id))
    else:
        if target_user_id not in ignored_users: await event_for_reply_obj.respond(USER_NOT_IGNORED_OWNER.format(user_id=target_user_id))
        else: ignored_users.remove(target_user_id); await event_for_reply_obj.respond(UNMUTE_CONFIRMATION_FOR_OWNER.format(user_id=target_user_id))
    logger.info(f"User {target_user_id} {action}d by owner.")

@client.on(events.NewMessage(pattern=r'^\.(Ø³Ù…Ø§Ø­|Ø§Ù„ØºØ§Ø¡)(?:\s+(\d+))?$', func=lambda e: (e.is_private and e.sender_id == bot_id) or (e.chat_id == bot_id and e.outgoing and e.pattern_match.group(2))))
async def manage_user_access(event):
    global bot_id
    command, user_id_arg_str = event.pattern_match.group(1), event.pattern_match.group(2)
    target_user_id = None; action = "mute" if command == "Ø³Ù…Ø§Ø­" else "unmute"
    if user_id_arg_str: target_user_id = int(user_id_arg_str)
    elif event.is_reply and event.is_private:
        reply_msg = await event.get_reply_message()
        if reply_msg: target_user_id = event.chat_id if reply_msg.sender_id == bot_id else reply_msg.sender_id
    elif event.is_private: target_user_id = event.chat_id
    reply_dest_event = event
    if event.chat_id == bot_id: reply_dest_event = await client.get_entity('me')
    if event.is_private and event.chat_id != bot_id:
        try: await event.delete()
        except: pass
    if target_user_id is None:
        error_reply_target = await client.get_entity('me') if event.chat_id == bot_id else event
        await error_reply_target.respond(TARGET_USER_NOT_FOUND_OWNER)
        return
    await _perform_mute_unmute(target_user_id, reply_dest_event, action)

@client.on(events.NewMessage(chats='me', pattern=r'^\.Ø§Ù„ØºØ§Ø¡Ùƒ$', outgoing=True))
async def unmute_all_users(event):
    global ignored_users
    if not ignored_users: await event.reply(UNMUTE_ALL_NO_IGNORED_OWNER); return
    num = len(ignored_users); ignored_users.clear(); logger.info(f"Owner cleared {num} users from ignore list.")
    await event.reply(UNMUTE_ALL_CONFIRMATION_OWNER + f" (ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ {num} Ù…Ø³ØªØ®Ø¯Ù…).")

@client.on(events.NewMessage(pattern=r'^\.Ùƒ$', func=lambda e: e.is_private and e.sender_id == bot_id))
async def complete_order_command(event):
    try: await event.delete()
    except: pass
    try:
        await client.send_message(event.chat_id, ORDER_COMPLETION_MESSAGE_USER)
        logger.info(f"Sent order completion message to user {event.chat_id}.")
    except Exception as e:
        logger.error(f"Failed to send .Ùƒ message to user {event.chat_id}: {e}", exc_info=True)
        await client.send_message('me', f"âš ï¸ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© .Ùƒ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {event.chat_id}.")

@client.on(events.NewMessage(incoming=True, pattern='^\.Ø¹Ø±Ø¶$', func=lambda e: e.is_private and e.sender_id == bot_id))
async def show_price_template_Ø¹Ø±Ø¶(event):
    try: await event.delete()
    except: pass
    await send_cumulative_total(event.chat_id, event, ask_confirmation=True)
    logger.info(f"Owner triggered .Ø¹Ø±Ø¶ for user {event.chat_id}, confirmation requested.")

@client.on(events.NewMessage(pattern=r'^\.Ø³$', func=lambda e: e.is_private and e.sender_id == bot_id))
async def owner_request_price_info(event):
    if bot_id is None: return
    try: await event.delete()
    except: pass
    user_prices_dict = user_prices.get(event.chat_id, {})
    actual_total_pages = sum(p[2] for p in user_prices_dict.values() if len(p) == 3) if user_prices_dict else 0
    await send_cumulative_total(event.chat_id, event, ask_confirmation=False, custom_template=OWNER_REQUESTED_PRICE_INFO_TEMPLATE, total_pages_info=actual_total_pages or "ØºÙŠØ± Ù…ØªØ§Ø­")
    logger.info(f"Owner requested price info using .Ø³ for user {event.chat_id}.")

@client.on(events.NewMessage(pattern=r'^\.Ø­Ù„Ùˆ$', outgoing=True, func=lambda e: e.is_reply and e.sender_id == bot_id))
async def save_media_as_document(event):
    logger.info(f"Owner used .Ø­Ù„Ùˆ in chat {event.chat_id}, replying to a message.")
    original_reply_msg = await event.get_reply_message()
    if not original_reply_msg or not original_reply_msg.media: await event.respond("âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… `.Ø­Ù„Ùˆ` Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© ÙˆØ³Ø§Ø¦Ø·."); return
    progress_msg = None; downloaded_path = None
    try:
        progress_msg = await event.respond(PROGRESS_MESSAGE_SAVE_MEDIA)
        sender = await original_reply_msg.get_sender()
        sender_info = f"ID: {sender.id}"
        if sender:
            name_parts = [getattr(sender, 'first_name', ''), getattr(sender, 'last_name', '')]
            sender_name = " ".join(filter(None, name_parts)).strip() or f"ID: {sender.id}"
            sender_info = f"{sender_name} (@{sender.username})" if sender.username else sender_name
        orig_fn = "media_file"
        if hasattr(original_reply_msg.media, 'document') and original_reply_msg.media.document:
            fn_attr = next((a for a in original_reply_msg.media.document.attributes if hasattr(a, 'file_name') and a.file_name), None)
            if fn_attr: orig_fn = fn_attr.file_name
        elif isinstance(original_reply_msg.media, MessageMediaPhoto): orig_fn = f"photo_{original_reply_msg.id}.jpg"
        final_caption = "\n".join([f"ØªÙ… Ø§Ù„Ø­ÙØ¸ Ù…Ù† Ø¯Ø±Ø¯Ø´Ø© ID: {original_reply_msg.chat_id}", f"Ø§Ù„Ù…Ø±Ø³Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ: {sender_info}", f"Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ (ØªÙ‚Ø±ÙŠØ¨ÙŠ): {orig_fn}", f"\nğŸ“ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ:\n{original_reply_msg.message}" if original_reply_msg.message else ""])
        temp_dir = "temp/"; os.makedirs(temp_dir, exist_ok=True)
        base, ext = os.path.splitext(orig_fn); unique_local_fn = f"{base}_{datetime.now().strftime('%Y%m%d%H%M%S%f')}{ext or ''}"; downloaded_path = os.path.join(temp_dir, unique_local_fn)
        downloaded_path = await client.download_media(original_reply_msg.media, file=downloaded_path)
        if downloaded_path and os.path.exists(downloaded_path):
            await client.send_file('me', downloaded_path, caption=final_caption, force_document=True)
            await event.respond("Ù…Ù…Ù…Ù…Ù…Ù…Ù…Ù…")
        else: raise Exception("Download path was None or file does not exist")
    except Exception as e_save:
        logger.error(f"Error in .Ø­Ù„Ùˆ: {e_save}", exc_info=True)
        await event.respond(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {type(e_save).__name__}")
    finally:
        if progress_msg:
            try: await progress_msg.delete()
            except: pass
        if downloaded_path and os.path.exists(downloaded_path):
            try: os.remove(downloaded_path)
            except: pass
        try: await event.delete()
        except: pass

# --- Ø£ÙˆØ§Ù…Ø± Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¶Ø§ÙØ© ---

@client.on(events.NewMessage(chats='me', pattern=r'^\.ØªÙ†Ø§ÙŠÙ…(?:\s+(.*))?$', outgoing=True))
async def set_custom_auto_reply(event):
    global custom_auto_reply_mode, custom_auto_reply_message
    message_text = event.pattern_match.group(1)
    if message_text and message_text.strip():
        custom_auto_reply_message = message_text.strip()
        custom_auto_reply_mode = True
        is_sleeping = False # Deactivate normal sleep mode
        logger.info(f"Auto-reply mode ENABLED with custom message: '{custom_auto_reply_message}'")
        await event.reply(f"âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ. Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n`{custom_auto_reply_message}`\n\nÙ„Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙˆØ¶Ø¹ØŒ Ø§Ø³ØªØ®Ø¯Ù… `.ÙƒØ§Ø¹Ø¯`.")
    else:
        await event.reply("âŒ ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø¯ÙŠÙ… Ù†Øµ Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ. Ù…Ø«Ø§Ù„: `.ØªÙ†Ø§ÙŠÙ… Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ`")

@client.on(events.NewMessage(chats='me', pattern=r'^\.Ø§Ø°Ø§Ø¹Ø©$', outgoing=True, func=lambda e: e.is_reply))
async def broadcast_message(event):
    reply_msg = await event.get_reply_message()
    if not reply_msg: return await event.edit("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡Ø§.")

    all_user_ids = {int(k.split('_')[1]) for k in user_last_interaction_time if k.startswith('general_')}

    if not all_user_ids: return await event.edit("â„¹ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù…ØªÙØ§Ø¹Ù„ÙˆÙ† Ù„Ø¨Ø« Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„ÙŠÙ‡Ù….")

    await event.edit(f"â³ Ø¬Ø§Ø±Ù Ø¨Ø« Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {len(all_user_ids)} Ù…Ø³ØªØ®Ø¯Ù…...")

    success_count = 0
    fail_count = 0
    for user_id in all_user_ids:
        try:
            await client.forward_messages(user_id, reply_msg)
            success_count += 1
            await asyncio.sleep(0.2) # To avoid flood waits
        except (UserIsBlocked, PeerIdInvalid):
            fail_count += 1
            logger.warning(f"Broadcast failed for user {user_id}: Blocked or invalid.")
        except Exception as e:
            fail_count += 1
            logger.error(f"Broadcast failed for user {user_id}: {e}", exc_info=True)

    final_report = f"âœ… ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¨Ø«:\n- Ø£ÙØ±Ø³Ù„Øª Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰: {success_count} Ù…Ø³ØªØ®Ø¯Ù…\n- ÙØ´Ù„Øª Ù„Ù€: {fail_count} Ù…Ø³ØªØ®Ø¯Ù…"
    await event.edit(final_report)
    logger.info(f"Broadcast completed. Success: {success_count}, Failed: {fail_count}")

@client.on(events.NewMessage(chats='me', pattern=r'^\.Ø³Ø¬Ù„$', outgoing=True))
async def report_and_reset_stats(event):
    global stats_confirmed_orders, stats_rejected_orders, stats_total_confirmed_files, stats_interacted_users

    interacted_users_list = []
    for user_id in stats_interacted_users:
        try:
            user = await client.get_entity(user_id)
            name = f"{user.first_name or ''} {user.last_name or ''}".strip() or f"ID: {user_id}"
            interacted_users_list.append(f"- {name} (`{user_id}`)")
        except:
            interacted_users_list.append(f"- ID: `{user_id}` (ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø§Ø³Ù…)")

    users_list_str = '\n'.join(interacted_users_list) if interacted_users_list else 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'

    report = (
        f"ğŸ“Š **ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø³Ø¬Ù„ (Ù…Ù†Ø° Ø¢Ø®Ø± Ø·Ù„Ø¨)**\n\n"
        f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªÙØ§Ø¹Ù„ÙŠÙ†: **{len(stats_interacted_users)}**\n"
        f"ğŸ‘ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚ Ø¹Ù„ÙŠÙ‡Ø§: **{stats_confirmed_orders}**\n"
        f"ğŸ‘ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©: **{stats_rejected_orders}**\n"
        f"ğŸ“‚ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª ÙÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚ Ø¹Ù„ÙŠÙ‡Ø§: **{stats_total_confirmed_files}**\n\n"
        f"ğŸ‘¤ **Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªÙØ§Ø¹Ù„ÙŠÙ†:**\n"
        f"{users_list_str}\n\n"
        f"_(ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø³Ø¬Ù„ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©)_"
    )

    await event.reply(report, parse_mode='md')
    logger.info("Generated and sent stats report via .Ø³Ø¬Ù„ command. Stats have been reset.")

    # Reset stats
    stats_confirmed_orders = 0
    stats_rejected_orders = 0
    stats_total_confirmed_files = 0
    stats_interacted_users = set()

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø®Ø§Ù…Ø³: Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ---
# ----------------------------------------------------------------------------------
@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private and e.sender_id != bot_id))
async def handle_any_message(event):
    global WELCOME_MESSAGE_TEXT, users_interacted_while_sleeping, user_confirmation_state, is_sleeping, custom_auto_reply_mode
    global global_daily_total_collected, user_last_interaction_time, user_status_messages, ignored_users
    global stats_confirmed_orders, stats_rejected_orders, stats_total_confirmed_files, stats_interacted_users

    user_id = event.sender_id; current_time = datetime.now()
    sender_entity = await event.get_sender()
    if not sender_entity or sender_entity.bot or user_id in ignored_users: return

    stats_interacted_users.add(user_id) # Add to interacted users for .Ø³Ø¬Ù„

    if custom_auto_reply_mode and not event.media:
        await event.respond(custom_auto_reply_message)
        logger.info(f"Sent custom auto-reply to user {user_id}.")
        return

    user_display_name = f"{sender_entity.first_name or ''} {sender_entity.last_name or ''}".strip() or "Ù…Ø³ØªØ®Ø¯Ù…"

    if is_sleeping:
        users_interacted_while_sleeping[user_id] = {'name': user_display_name, 'interaction_time': current_time, 'type': 'text'}

    welcome_key = f"welcome_{user_id}"
    last_welcome_time = user_last_interaction_time.get(welcome_key)
    if not event.media and (last_welcome_time is None or (current_time - last_welcome_time) >= WELCOME_COOLDOWN):
        await event.respond(WELCOME_MESSAGE_TEXT.format(user_name=user_display_name))
        user_last_interaction_time[welcome_key] = current_time

    user_last_interaction_time[f"general_{user_id}"] = current_time

    if user_id in user_confirmation_state and event.raw_text:
        reply_lower = event.raw_text.strip().lower(); state = user_confirmation_state[user_id]
        is_direct_reply = event.reply_to_msg_id == state.get('message_id_of_question')
        is_relevant_timing = (current_time - state.get('time_asked', current_time - timedelta(days=1))) < timedelta(minutes=30)
        action = "confirm" if any((" " + k + " ") in f" {reply_lower} " for k in KEYWORDS_CONFIRM) else "cancel" if any((" " + k + " ") in f" {reply_lower} " for k in KEYWORDS_CANCEL) else None

        if action and (is_direct_reply or is_relevant_timing):
            try: await event.delete()
            except: pass
            if state.get('message_id_of_question'):
                try: await client.delete_messages(event.chat_id, state.get('message_id_of_question'))
                except: pass

            orig_total_msg_id = state.get('original_total_message_id')
            user_confirmation_state.pop(user_id, None)

            if action == "confirm":
                total_base = sum(p[0] for p in user_prices.get(user_id, {}).values())
                if total_base > 0: global_daily_total_collected += total_base

                confirmed_files_count = len(user_prices.get(user_id, {}))
                stats_confirmed_orders += 1
                stats_total_confirmed_files += confirmed_files_count

                logger.info(f"User {user_id} confirmed. Added {total_base} to daily. Logged stats: +1 order, +{confirmed_files_count} files.")

                final_conf_msg = ORDER_CONFIRMED_SLEEPING_MESSAGE if is_sleeping else ORDER_CONFIRMED_AWAKE_MESSAGE
                await client.send_message(event.chat_id, final_conf_msg, reply_to=orig_total_msg_id)
                link_name = f"[{user_display_name}](tg://user?id={user_id})" if sender_entity.username else f"{user_display_name} (ID: {user_id})"
                await send_notification(f"ğŸ‘ {link_name} ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø±.\nØ§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: {total_base} Ø¯ÙŠÙ†Ø§Ø±.", parse_mode='md')
                if user_id in user_prices: user_prices.pop(user_id)
            elif action == "cancel":
                stats_rejected_orders += 1
                logger.info(f"User {user_id} cancelled. Logged stats: +1 rejection.")
                await client.send_message(event.chat_id, CONFIRMATION_REJECTED_ASK_REASON_MESSAGE, reply_to=orig_total_msg_id)
                if user_id in user_prices: user_prices.pop(user_id)
            return

    if not event.media and event.raw_text:
        if user_id not in user_confirmation_state and user_prices.get(user_id):
            await send_cumulative_total(user_id, event, ask_confirmation=True)
            return
        elif user_id in user_confirmation_state:
             return
        else:
            if user_id in user_status_messages:
                try: await user_status_messages.pop(user_id).delete()
                except: pass
            if not is_sleeping:
                user_status_messages[user_id] = await event.respond(WAITING_MESSAGE_NORMAL)
            return

@client.on(events.NewMessage(incoming=True, func=lambda e: e.media and e.is_private and e.sender_id != bot_id))
async def handle_media(event):
    global is_sleeping, ignored_users, user_status_messages, user_prices, custom_auto_reply_mode
    global users_interacted_while_sleeping, user_last_interaction_time, stats_interacted_users

    user_id = event.sender_id; sender_entity = await event.get_sender()
    if not sender_entity or sender_entity.bot or user_id in ignored_users: return

    stats_interacted_users.add(user_id) # Add to interacted users for .Ø³Ø¬Ù„

    # --- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¯Ù…ÙŠØ± ---
    if hasattr(event.media, 'ttl_seconds') and event.media.ttl_seconds:
        logger.info(f"Detected self-destructing media from user {user_id} (TTL: {event.media.ttl_seconds}s). Attempting to save.")
        user_display_name = f"{sender_entity.first_name or ''} {sender_entity.last_name or ''}".strip() or f"ID: {user_id}"
        downloaded_path_ttl = None
        try:
            temp_dir_ttl = "temp/"; os.makedirs(temp_dir_ttl, exist_ok=True)
            downloaded_path_ttl = await event.download_media(file=temp_dir_ttl)
            if downloaded_path_ttl and os.path.exists(downloaded_path_ttl):
                caption = f"ğŸ’¾ ØªÙ… Ø­ÙØ¸ ÙˆØ³Ø§Ø¦Ø· Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¯Ù…ÙŠØ± Ù…Ù†:\n{user_display_name} (`{user_id}`)"
                await client.send_file('me', downloaded_path_ttl, caption=caption, force_document=False, parse_mode='md')
                logger.info(f"Successfully saved self-destructing media from user {user_id} to 'me'.")
                await send_notification(f"âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ÙˆØ­ÙØ¸ Ù…Ù„Ù Ù…Ø¤Ù‚Øª Ù…Ù†: {user_display_name}.")
            else:
                raise Exception("Download path was None or file does not exist.")
        except Exception as e:
            logger.error(f"Failed to save self-destructing media from user {user_id}: {e}", exc_info=True)
            await send_notification(f"âš ï¸ ÙØ´Ù„ Ø­ÙØ¸ Ù…Ù„Ù Ù…Ø¤Ù‚Øª Ù…Ù†: {user_display_name}. Ø§Ù„Ø®Ø·Ø£: {type(e).__name__}")
        finally:
            if downloaded_path_ttl and os.path.exists(downloaded_path_ttl):
                try: os.remove(downloaded_path_ttl)
                except: pass
        return # Stop further processing

    if custom_auto_reply_mode:
        await event.respond(custom_auto_reply_message)
        logger.info(f"Sent custom auto-reply (for media) to user {user_id}.")
        return

    user_display_name = f"{sender_entity.first_name or ''} {sender_entity.last_name or ''}".strip() or "Ù…Ø³ØªØ®Ø¯Ù…"

    if user_id in user_status_messages:
        try: await user_status_messages.pop(user_id).delete()
        except: pass

    user_last_interaction_time[f"general_{user_id}"] = datetime.now()
    if is_sleeping:
        users_interacted_while_sleeping[user_id] = {'name': user_display_name, 'interaction_time': datetime.now(), 'type': 'media'}

    is_doc = isinstance(event.media, MessageMediaDocument)
    is_handled_doc = False; ext = ''; filename_for_display = 'unknown_file'; filename_for_processing = ''

    if is_doc and event.media.document:
        fn_attr = next((a for a in event.media.document.attributes if hasattr(a, 'file_name') and a.file_name), None)
        filename_for_display = fn_attr.file_name if fn_attr else f"document_{event.media.document.id}"
        filename_for_processing = filename_for_display
        file_ext_from_name = os.path.splitext(filename_for_display)[1].lower()
        mime_type = event.media.document.mime_type.lower() if event.media.document.mime_type else ""

        supported_exts = ['.pdf', '.docx', '.pptx']
        supported_mimes_map = { 'application/pdf': '.pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx', 'application/msword': '.docx', 'application/vnd.ms-word.document.macroenabled.12': '.docx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation': '.pptx', 'application/vnd.ms-powerpoint': '.pptx', 'application/vnd.ms-powerpoint.presentation.macroenabled.12': '.pptx' }

        if file_ext_from_name in supported_exts: is_handled_doc, ext = True, file_ext_from_name
        elif mime_type in supported_mimes_map:
            is_handled_doc, ext = True, supported_mimes_map[mime_type]
            base_fn, _ = os.path.splitext(filename_for_display); filename_for_processing = base_fn + ext

    if is_handled_doc and ext:
        calc_msg = None; file_path = None
        try:
            calc_msg = await event.reply(CALCULATING_MESSAGE)
            temp_dir_path = "temp/"; os.makedirs(temp_dir_path, exist_ok=True)
            safe_basename = "".join(c for c in os.path.basename(filename_for_processing) if c.isalnum() or c in ('.', '_', '-'))
            unique_fn = f"{user_id}_{event.id}_{datetime.now().strftime('%Y%m%d%H%M%S%f')}_{safe_basename}"
            file_path = os.path.join(temp_dir_path, unique_fn)
            await event.download_media(file_path)
            pages = await count_pages_for_document(file_path, ext)
            if pages == 0: raise ValueError(f"Counted 0 pages for '{filename_for_display}'.")
            base_p, cover_p = calculate_price(pages)
            if calc_msg: await calc_msg.delete()
            price_msg = (f"ğŸ“„ Ù…Ù„Ù: {filename_for_display}\nğŸ“– Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª/Ø§Ù„Ø´Ø±Ø§Ø¦Ø­: {pages}\n"
                         f"ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø¨Ø¯ÙˆÙ† Ø¬Ù„Ø§Ø¯: {base_p} Ø¯ÙŠÙ†Ø§Ø±\nğŸ·ï¸ Ø§Ù„Ø³Ø¹Ø± Ù…Ø¹ Ø¬Ù„Ø§Ø¯: {cover_p} Ø¯ÙŠÙ†Ø§Ø±"
                         f"{FILE_PROCESSED_ADD_TO_ORDER_PROMPT_TOTAL}")
            await event.reply(price_msg)
            user_prices.setdefault(user_id, {})[event.id] = (base_p, cover_p, pages)
        except Exception as e:
            if calc_msg: await calc_msg.delete()
            await event.respond(PROCESSING_ERROR_MESSAGE)
            logger.error(f"Error processing doc '{filename_for_display}' for {user_id}: {e}", exc_info=True)
        finally:
            if file_path and os.path.exists(file_path):
                try: os.remove(file_path)
                except: pass
    else:
        # For any other media type (photos, videos, unsupported docs)
        await event.respond(FILE_TYPE_ERROR_MESSAGE)
        link_name = f"[{user_display_name}](tg://user?id={user_id})" if sender_entity.username else f"{user_display_name} (ID: {user_id})"
        await send_notification(f"âš ï¸ {link_name} Ø£Ø±Ø³Ù„ ÙˆØ³Ø§Ø¦Ø· ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø© Ù„Ù„ØªØ³Ø¹ÙŠØ±.", parse_mode='md')


@client.on(events.MessageDeleted())
async def handler_message_deleted(event):
    if not event.chat_id or event.chat_id <= 0: return
    global user_prices
    if event.chat_id in user_prices:
        prices_changed = False
        for del_id in event.deleted_ids:
            if del_id in user_prices[event.chat_id]:
                user_prices[event.chat_id].pop(del_id); prices_changed = True
        if not user_prices[event.chat_id]: del user_prices[event.chat_id]
        if prices_changed:
            remaining = user_prices.get(event.chat_id, {})
            if remaining:
                total_base = sum(p[0] for p in remaining.values()); total_cover = sum(p[1] for p in remaining.values())
                await client.send_message(event.chat_id, f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø¨Ø¹Ø¯ Ø­Ø°Ù Ø¨Ø¹Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ±.\n{CUMULATIVE_TOTAL_MESSAGE_TEMPLATE.format(total_base=total_base, total_cover=total_cover)}")
            else:
                await client.send_message(event.chat_id, "ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø³Ø¹Ø±Ø©. Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¬Ù…ÙˆØ¹ Ø­Ø§Ù„ÙŠÙ‹Ø§.")


# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø³Ø§Ø¯Ø³: Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ---
# ----------------------------------------------------------------------------------
async def main():
    global bot_id, bot_start_time, daily_report_task, client
    if not SESSION_STRING or SESSION_STRING.strip() == "":
        logger.critical("CRITICAL ERROR: SESSION_STRING is not set."); return

    logger.info("â³ Bot starting...")
    try:
        await client.start(phone=lambda: input("Please enter your number or bot token: "), password=lambda: input("Please enter your password: "))
        logger.info("Client connected and authorized.")

        me = await client.get_me()
        bot_id = me.id; bot_start_time = datetime.now()
        bot_name_display = f"{me.first_name or ''} {me.last_name or ''}".strip() or me.username or f"ID: {bot_id}"
        logger.info(f"âœ… Bot '{bot_name_display}' started! ID: {bot_id}")
        await send_notification(f"ğŸš€ Ø§Ù„Ø¨ÙˆØª ({bot_name_display}) ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†!")

        os.makedirs("temp/", exist_ok=True)
        current_loop = asyncio.get_event_loop()
        daily_report_task = current_loop.create_task(report_daily_total())

        logger.info("Bot is now listening for incoming events...")
        await client.run_until_disconnected()

    except Exception as e_fatal:
        logger.critical(f"ğŸ’¥ CRITICAL UNHANDLED ERROR in main: {e_fatal}", exc_info=True)
    finally:
        logger.info("--- Initiating shutdown sequence ---")
        if daily_report_task and not daily_report_task.done(): daily_report_task.cancel()
        if client.is_connected(): await client.disconnect()
        temp_dir_cleanup = "temp/"
        if os.path.exists(temp_dir_cleanup):
            for item_name in glob.glob(os.path.join(temp_dir_cleanup, "*")):
                try: os.remove(item_name)
                except: pass
        logger.info("âœ… Bot shutdown process finished.")

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø³Ø§Ø¨Ø¹: Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„ØªØ´ØºÙŠÙ„ ---
# ----------------------------------------------------------------------------------
if __name__ == '__main__':
    try:
        asyncio.run(main())
    except RuntimeError as e_runtime_main:
        if "event loop is already running" in str(e_runtime_main).lower() and 'nest_asyncio' in sys.modules:
            logger.info("Asyncio loop already running, creating task on existing loop.")
            loop = asyncio.get_event_loop()
            loop.create_task(main())
        else:
             logger.critical(f"Unhandled RuntimeError at script entry: {e_runtime_main}", exc_info=True)
    except Exception as e_top_level_main:
        logger.critical(f"Unhandled top-level exception at script entry: {e_top_level_main}", exc_info=True)

await main()
