# -*- coding: utf-8 -*-
"""Bot me Al MUSTAFA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dZ-uN7yPoXV5jqQ4hR8tbng9wtskn5ft
"""

!pip install pymupdf

!pip install python-docx

!pip install python-pptx

!pip install telethon

!pip install python-docx

!pip install matplotlib-venn

!apt-get -qq install -y libfluidsynth1

# https://pypi.python.org/pypi/pydot
!apt-get -qq install -y graphviz && pip install pydot
import pydot

!pip install cartopy
import cartopy

# هذا الكود مخصص للبيئات مثل Google Colab أو Jupyter Notebook
# حيث يمكن تشغيل أوامر النظام باستخدام علامة التعجب '!'

print("الخطوة 1: تحديث قائمة الحزم (apt)...")
# الأمر '!apt-get -qq update' مشابه لـ '!apt-get update' ولكنه أقل إخراجًا (quiet)
# إذا كنت تريد رؤية كل المخرجات، استخدم: !apt-get update
# استخدام get_ipython().system() هو الطريقة الأكثر موثوقية لتشغيل أوامر النظام في IPython/Jupyter
try:
    get_ipython().system('apt-get -qq update')
    print("تم تحديث قائمة الحزم بنجاح.")
except Exception as e:
    print(f"حدث خطأ أثناء تحديث قائمة الحزم: {e}")
    print("قد تحتاج إلى تشغيل هذا الأمر بصلاحيات sudo إذا كنت في بيئة لينكس محلية.")
print("-" * 30)

print("الخطوة 2: تثبيت الاعتمادية على مستوى النظام 'libarchive-dev'...")
# الخيار '-y' يجيب بـ "yes" تلقائيًا على أي أسئلة أثناء التثبيت
# الخيار '-qq' لتقليل المخرجات
try:
    get_ipython().system('apt-get install -y -qq libarchive-dev')
    print("اكتملت محاولة تثبيت 'libarchive-dev'.")
    # لا يوجد تأكيد مباشر للنجاح من apt-get -qq، ولكن إذا فشل، سيظهر خطأ.
except Exception as e:
    print(f"حدث خطأ أثناء تثبيت 'libarchive-dev': {e}")
print("-" * 30)

print("الخطوة 3: تثبيت مكتبة بايثون 'libarchive' باستخدام pip...")
# الخيار '-U' يعني الترقية إلى أحدث إصدار إذا كانت مثبتة بالفعل
# الخيار '-q' لتقليل المخرجات
try:
    get_ipython().system('pip install -U -q libarchive')
    print("اكتملت محاولة تثبيت مكتبة بايثون 'libarchive'.")
except Exception as e:
    print(f"حدث خطأ أثناء تثبيت مكتبة بايثون 'libarchive' باستخدام pip: {e}")
print("-" * 30)

print("الخطوة 4: محاولة استيراد مكتبة libarchive في بايثون...")
try:
    import libarchive
    print("\n🎉 نجاح!")
    print("تم استيراد مكتبة 'libarchive' بنجاح.")
    print("يمكنك الآن استخدامها في الكود الخاص بك.")
    # يمكنك إضافة كود بسيط يستخدم المكتبة هنا للاختبار إذا أردت
    # مثال:
    # print(f"إصدار libarchive المستخدم: {libarchive.version_details()}")
except ModuleNotFoundError:
    print("\n❌ خطأ: فشل استيراد مكتبة 'libarchive'.")
    print("هذا يعني غالبًا أن الخطوات السابقة (تثبيت libarchive-dev أو pip install libarchive) لم تكتمل بنجاح.")
    print("يرجى مراجعة أي رسائل خطأ ظهرت في المخرجات أعلاه.")
    print("إذا ظهر خطأ '404 Not Found' في الخطوة 2، فهذا يعني أن 'apt-get update' ربما لم ينجح أو أن الحزمة غير متوفرة.")
except Exception as e:
    print(f"\n❌ خطأ آخر غير متوقع أثناء محاولة استيراد 'libarchive': {e}")

print("-" * 30)
print("اكتمل تنفيذ جميع الخطوات.")

pip install nest_asyncio

!pip install telethon PyMuPDF python-docx python-pptx nest_asyncio

!pip install PyMuPDF

!pip install -U telethon

from telethon.tl.types import PeerUser, MessageMediaPhoto, MessageMediaDocument
# تأكد من عدم وجود MessageMediaVideo, MessageMediaVoice, MessageMediaAudio هنا

!pip install PyMuPDF

pip install -U telethon PyMuPDF python-docx python-pptx nest_asyncio

# ----------------------------------------------------------------------------------
# --- القسم الأول: الاستيرادات والإعدادات الأولية (بما في ذلك logging) ---
# ----------------------------------------------------------------------------------
import os
import asyncio
import math
# --- تأكد من تثبيت هذه المكتبات أولاً في Colab باستخدام: ---
# --- !pip install -U telethon PyMuPDF python-docx python-pptx nest_asyncio ---
import fitz  # PyMuPDF
import docx
import pptx
# -----------------------------------------------------------
from telethon import TelegramClient, events
from telethon.sessions import StringSession

# --- بداية التعديل: حل نهائي وشامل لجميع مشاكل الاستيراد ---
# قائمة بجميع الأخطاء التي نحتاجها
error_classes = [
    'UserIsBlocked',
    'PeerIdInvalid',
    'MessageDeleteForbiddenError',
    'FileReferenceExpiredError'
]

# سيقوم هذا الكود باستيراد كل خطأ، وإذا فشل، سيقوم بإنشاء فئة وهمية له.
for error_name in error_classes:
    try:
        # محاولة الاستيراد من المكان الأحدث
        exec(f"from telethon.errors import {error_name}")
    except ImportError:
        try:
            # إذا فشل، محاولة الاستيراد من المكان الأقدم
            exec(f"from telethon.errors.rpcerrorlist import {error_name}")
        except ImportError:
            # إذا فشل كل شيء، أنشئ فئة وهمية
            globals()[error_name] = type(error_name, (Exception,), {})
            print(f"WARNING: '{error_name}' not found. Created a dummy class. It's highly recommended to update Telethon with '!pip install -U telethon' and restart the runtime.")
# --- نهاية التعديل ---

from telethon.tl.types import PeerUser, MessageMediaPhoto, MessageMediaDocument, User
from telethon.tl import types as telethon_types # لاستخدام types.DocumentAttributeAudio
from datetime import datetime, timedelta
import sys
import traceback
import glob
import nest_asyncio
import logging

# تطبيق nest_asyncio
try:
    nest_asyncio.apply()
    print("nest_asyncio applied for IPython/Jupyter environment.")
except RuntimeError as e:
    if "cannot apply nest_asyncio" in str(e).lower():
        print(f"nest_asyncio may have already been applied: {e}")
    else:
        raise

# إعداد التسجيل (Logging Setup)
LOG_FILENAME = 'bot_activity.log'
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILENAME, mode='a', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('MyTelegramBot')

# ----------------------------------------------------------------------------------
# --- القسم الثاني: متغيرات الإعدادات العامة والثوابت ---
# ----------------------------------------------------------------------------------
API_ID = 16504919  # استبدل بـ API_ID الخاص بك
API_HASH = 'e9ddbc4aa70093979dcc2d20153fba08'  # استبدل بـ API_HASH الخاص بك
SESSION_STRING = '1ApWapzMBuwejlRF09skSWxYWFj0MbNtZ4NkoYlqgaBviKXmI-3-QroMfcOZ26AYle1-eklyLTaeoJD6QWxIhNDnxWapeYaqRKknoGoTtPvJ9e7UivDk2cTPZ2MxCMfH6qW7OBUiPIlxJA-kzIRMRfVzydjM-zWI0N4h5FS9_Sx1aeCMpBlOi2yqzius9EiXdk4aEnI9aWndxCEx_a_SuyPN5ljTgFK8JB-oGKwQ5_2eD1r2NI0SOZ9dUGLhrtU3Z62SlvnAWgWEAVbCDuPMm9svEi9x5LkhIiIEXGuGWIyFv7FtJfh_1Uj0VwziT73ejai1akINyxy84eHMltF8tZsXuVkHCMTU=' # <--- هام جداً: ضع سلسلة جلستك هنا

client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)

NOTIFICATION_CHAT = -1002356701524
is_sleeping = False
user_prices = {} # سيخزن الآن: user_prices[user_id][msg_id] = (base_price, cover_price, pages)
user_status_messages = {}
user_last_interaction_time = {}
ignored_users = set()
bot_id = None
global_daily_total_collected = 0
bot_start_time = None
daily_report_task = None
user_confirmation_state = {}
users_interacted_while_sleeping = {}

# --- متغيرات الميزات الجديدة ---
custom_auto_reply_mode = False
custom_auto_reply_message = "صاحب الحساب غير متوفر حاليًا. سيتم الرد عليك لاحقًا."
stats_confirmed_orders = 0
stats_rejected_orders = 0
stats_total_confirmed_files = 0
stats_interacted_users = set()
# --------------------------------

PRICE_PER_PAGE_LT50 = 50
PRICE_PER_PAGE_GTE50 = 40
COVER_BINDING_COST = 500

DEFAULT_WELCOME_MESSAGE = "👋 أهلاً بك {user_name} في بوت حساب أسعار الطباعة! أرسل لي ملف PDF, DOCX, أو PPTX وسأقوم بحساب السعر لك. يمكنك إرسال أي رسالة نصية أخرى بعد إرسال الملفات للحصول على المجموع الكلي."
WELCOME_MESSAGE_TEXT = DEFAULT_WELCOME_MESSAGE
WELCOME_COOLDOWN = timedelta(hours=12)
DEFAULT_OWNER_ALERT_MESSAGE = "🔔 تنبيه للمالك: تم استلام ملف/رسالة جديدة من مستخدم."
OWNER_ALERT_MESSAGE_TEXT = DEFAULT_OWNER_ALERT_MESSAGE
APOLOGY_MESSAGE_AFTER_PRICE_WHEN_SLEEPING = "\n\n📝 تم حساب السعر. صاحب المكتبة غير متوفر حاليًا، يرجى الانتظار حتى عودته لمتابعة طلبك."
WAITING_MESSAGE_NORMAL = "شكرًا لرسالتك. سيتم الرد عليك بأقرب وقت ممكن."
CALCULATING_MESSAGE = "⏳ جار احتساب... يرجى الانتظار."
FILE_TYPE_ERROR_MESSAGE = "⚠️ يرجى إرسال ملف PDF، DOCX، أو PPTX فقط. الصور والأنواع الأخرى من الملفات غير مدعومة حالياً لحساب السعر."
COUNT_PAGES_ERROR_MESSAGE = "❌ لا يمكن معالجة هذا الملف: لم يتمكن البوت من قراءة عدد الصفحات أو الملف تالف."
PROCESSING_ERROR_MESSAGE = "❌ حدث خطأ أثناء معالجة الملف. يرجى المحاولة مرة أخرى."
MUTE_CONFIRMATION_FOR_OWNER = "✅ تم تجاهل المستخدم `{user_id}` بنجاح. لن يتم الرد على رسائله."
UNMUTE_CONFIRMATION_FOR_OWNER = "✅ تم إلغاء تجاهل المستخدم `{user_id}` بنجاح. سيعود البوت للرد على رسائله."
USER_ALREADY_IGNORED_OWNER = "⚠️ المستخدم `{user_id}` موجود بالفعل في قائمة التجاهل."
USER_NOT_IGNORED_OWNER = "⚠️ المستخدم `{user_id}` ليس في قائمة التجاهل أصلاً."
TARGET_USER_NOT_FOUND_OWNER = "❌ لم يتم تحديد المستخدم. استخدم الأمر بالرد على رسالة المستخدم، أو بتضمين ID المستخدم، أو استخدم الأمر `.سماح <ID>` / `.الغاء <ID>` في المحفوظات."
DAILY_REPORT_MESSAGE_TEMPLATE = "📊 التقرير اليومي ({date}):\nالمجموع الكلي للمبالغ التي تم عرضها للمستخدمين (وتم تأكيدها) خلال الـ 24 ساعة الماضية: {total} دينار."
PRICE_UPDATE_SUCCESS_TEMPLATE = "✅ تم تحديث `{price_name}` إلى {new_price} دينار."
PRICE_UPDATE_ERROR = "❌ خطأ في تعديل السعر. يرجى التأكد من الأمر والقيمة العددية (مثال: `.ت1 60`)."
PRICE_UPDATE_INVALID_VALUE = "❌ القيمة المدخلة غير صحيحة. يرجى إدخال قيمة عددية صحيحة (مثال: `.ت1 60`)."
CUMULATIVE_TOTAL_MESSAGE_TEMPLATE = ("📊 המجموع الكلي للملفات المرسلة حتى الآن:\n"
                                   "بدون جلاد: {total_base} دينار\n"
                                   "مع جلاد: {total_cover} دينار")
OWNER_REQUESTED_PRICE_INFO_TEMPLATE = ("📄 معلومات التسعير للمستخدم (بناءً على طلبك):\n"
                                     "📖 إجمالي عدد الصفحات (للملفات المسعرة): {total_pages}\n"
                                     "💰 السعر الأساسي (بدون جلاد): {total_base} دينار\n"
                                     "🏷️ السعر مع جلاد: {total_cover} دينار")
CONFIRMATION_PROMPT_MESSAGE = "\n\n🤔 هل أنت موافق على سحب الملفات المرسلة بهذا السعر؟\nأجب بالكلمات المناسبة مثل `نعم`/`موافق` أو `لا`/`ارفض`."
ORDER_CONFIRMED_AWAKE_MESSAGE = "✅ تم تأكيد طلبك وجارٍ معالجته. سيتم التواصل معك قريبًا."
ORDER_CONFIRMED_SLEEPING_MESSAGE = "✅ تم تسجيل طلبك. سيتم التواصل معك عند عودة صاحب المكتبة لمتابعة التفاصيل."
CONFIRMATION_REJECTED_ASK_REASON_MESSAGE = "تم إلغاء الطلب. إذا أمكن، يرجى ذكر سبب الرفض (اختياري)."
PROGRESS_MESSAGE_SAVE_MEDIA = "دقيقة نت ضعيف خل تفتح ❤️"
FILE_PROCESSED_ADD_TO_ORDER_PROMPT_TOTAL = (
    "\n\n✅ تم إضافة هذا الملف إلى طلبك. أرسل أي رسالة نصية لعرض المجموع الكلي وتأكيد الطلب."
)
ORDER_COMPLETION_MESSAGE_USER = (
    "عزيزي المستخدم، تم إكمال طلبك بنجاح.\n"
    "يرجى استلامه أو طلب توصيل مع ذكر المعلومات التالية:\n"
    "- الاسم:\n"
    "- رقم الهاتف:\n"
    "- أقرب نقطة دالة:\n\n"
    "شكرًا لاختيارنا."
)
UNMUTE_ALL_CONFIRMATION_OWNER = "✅ تم إلغاء تجاهل جميع المستخدمين بنجاح."
UNMUTE_ALL_NO_IGNORED_OWNER = "ℹ️ لا يوجد مستخدمون في قائمة التجاهل حاليًا."

KEYWORDS_CONFIRM = ["نعم", "اي", "أجل", "موافق", "موافقة", "yes", "ok", "confirm", "yep", "yeah", "تمام", "اوكي", "وك", "اوك", "تم"]
KEYWORDS_CANCEL = ["لا", "كلا", "ارفض", "no", "cancel", "nope", "الغاء"]

MENU_HEADER = "📋 قائمة أوامر بوت الطباعة:\n"
MAIN_MENU_OPTIONS = {
    "1": "أوامر حالة البوت والمعلومات",
    "2": "أوامر تعديل الأسعار",
    "3": "أوامر إدارة المستخدمين",
    "4": "أوامر متقدمة وإحصائيات",
    "5": "أمر حفظ الوسائط (.حلو)",
    "6": "ملاحظات إضافية"
}

# ----------------------------------------------------------------------------------
# --- القسم الثالث: الدوال المساعدة ---
# ----------------------------------------------------------------------------------
def get_main_menu_text():
    text = MENU_HEADER
    for key, value in MAIN_MENU_OPTIONS.items():
        text += f"  `.م{key}` - {value}\n"
    text += "\nأرسل الأمر مع الرقم لعرض التفاصيل (مثال: `.م1`)"
    return text

def get_status_commands_text():
    return (
        "🔹 أوامر حالة البوت والمعلومات (تُستخدم في المحفوظات 'Saved Messages'):\n"
        "  `.نايم` - تفعيل وضع النوم (تنبيهات فقط).\n"
        "  `.كاعد` - تفعيل وضع الاستعداد (يلغي وضع النوم والرد التلقائي).\n"
        "  `.م` - العودة إلى القائمة الرئيسية للأوامر.\n"
        "  `.تفعيل` - عرض حالة البوت الحالية ومدة التشغيل.\n"
        "  `.فحص` - إجراء فحص لحالة البوت العامة.\n"
        "  `.تن <رسالة>` - تغيير رسالة التنبيه للمالك.\n"
        "  `.تر <رسالة>` - تغيير رسالة الترحيب للمستخدمين (استخدم {user_name}).\n"
        "\nللرئيسية: `.م`"
    )

def get_prices_commands_text():
    return (
        f"💰 أوامر تعديل الأسعار (القيم الحالية بين الأقواس []):\n"
        f"  `.ت1 <قيمة>` - سعر الصفحة (< 50) [{PRICE_PER_PAGE_LT50}]\n"
        f"  `.ت2 <قيمة>` - سعر الصفحة (>= 50) [{PRICE_PER_PAGE_GTE50}]\n"
        f"  `.ت3 <قيمة>` - تكلفة الجلاد [{COVER_BINDING_COST}]\n"
        "\nللرئيسية: `.م`"
    )

def get_users_commands_text():
    return (
        "👥 أوامر إدارة المستخدمين (خاصة بالمالك):\n"
        "  * في **المحادثة الخاصة مع المستخدم**:\n"
        "    `.سماح` (أو بالرد على رسالة المستخدم) - لتجاهل المستخدم الحالي.\n"
        "    `.سماح <user_ID>` - لتجاهل المستخدم المحدد بالـ ID.\n"
        "    `.الغاء` (أو بالرد على رسالة المستخدم) - لإلغاء تجاهل المستخدم الحالي.\n"
        "    `.الغاء <user_ID>` - لإلغاء تجاهل المستخدم المحدد بالـ ID.\n"
        "    `.عرض` - لعرض المجموع الكلي لملفات المستخدم المرسلة (يُرسل للمستخدم، مع سؤال تأكيد).\n"
        "    `.س` - لعرض المجموع الكلي للمستخدم مع عدد الصفحات (يُرسل للمستخدم، بدون سؤال تأكيد).\n"
        "    `.ك` - لإرسال رسالة إكمال الطلب للمستخدم.\n"
        "  * في **المحفوظات ('me')**:\n"
        "    `.سماح <user_ID>` - لتجاهل المستخدم المحدد بالـ ID.\n"
        "    `.الغاء <user_ID>` - لإلغاء تجاهل المستخدم المحدد بالـ ID.\n"
        "    `.الغاءك` - لإلغاء تجاهل جميع المستخدمين.\n"
        "\nللرئيسية: `.م`"
    )

def get_advanced_commands_text():
    return (
        "⚙️ أوامر متقدمة وإحصائيات:\n"
        "  `.تنايم <نص الرسالة>` - تفعيل وضع الرد التلقائي برسالة مخصصة. للإلغاء استخدم `.كاعد`.\n"
        "  `.اذاعة` (بالرد على رسالة) - بث الرسالة لجميع المستخدمين الذين تفاعلوا مع البوت.\n"
        "  `.سجل` - عرض تقرير تفاعلات المستخدمين (الموافقات، الرفض، عدد الملفات) ثم إعادة تعيينه.\n"
        "\nللرئيسية: `.م`"
    )

def get_notes_text():
    return (
        "📝 ملاحظات إضافية:\n"
        "  - البوت يقوم بحفظ الوسائط ذاتية التدمير تلقائيًا في رسائلك المحفوظة.\n"
        "  - البوت يعمل فقط في المحادثات الخاصة مع المستخدمين (وليس البوتات الأخرى).\n"
        "  - بعد عرض المجموع الكلي، سيسأل البوت المستخدم لتأكيد عملية السحب.\n"
        "  - حذف رسالة ملف سيؤدي إلى خصم سعره وعدد صفحاته من المجموع الكلي المخزن.\n"
        "  - هناك تقرير يومي للمبالغ المجمعة يتم إرساله إلى المحفوظات 'Saved Messages'.\n"
        "  - البيانات (أسعار المستخدمين، قائمة التجاهل، إحصائيات السجل) مؤقتة وتُفقد عند إعادة تشغيل البوت.\n"
        "\nللرئيسية: `.م`"
    )

def get_save_command_text():
    return (
        "📥 أمر حفظ الوسائط (`.حلو`):\n"
        "  - استخدم الأمر `.حلو` **بالرد على رسالة** تحتوي على وسائط (صورة، فيديو، ملف، إلخ).\n"
        "  - سيقوم البوت بحفظ هذه الوسائط كـ **مستند (ملف)** في رسائلك المحفوظة ('me').\n"
        "  - مفيد بشكل خاص للوسائط من المجموعات التي لا تسمح بالحفظ المباشر، أو لتحويل الصور إلى ملفات.\n"
        "  - سيتم تضمين معلومات عن المصدر الأصلي للوسائط في تعليق الملف المحفوظ.\n"
        "\nللرئيسية: `.م`"
    )

def round_up_to_250(x): return int(math.ceil(x / 250.0) * 250)

def calculate_price(pages_count):
    price_per_page = PRICE_PER_PAGE_LT50 if pages_count < 50 else PRICE_PER_PAGE_GTE50
    base_p = pages_count * price_per_page
    return round_up_to_250(base_p), round_up_to_250(base_p + COVER_BINDING_COST)

async def run_sync_in_thread(func, *args, **kwargs): return await asyncio.to_thread(func, *args, **kwargs)

async def count_pages_for_document(file_path, ext):
    try:
        if ext == '.pdf':
            doc = await run_sync_in_thread(fitz.open, file_path); pages = await run_sync_in_thread(lambda d: len(d), doc); await run_sync_in_thread(doc.close); return pages
        elif ext == '.docx':
            doc = await run_sync_in_thread(docx.Document, file_path)
            # تقدير عدد الصفحات للـ DOCX غير دقيق، هذه مجرد محاولة بسيطة
            return doc.sections[0].page_height.inches * len(doc.sections) if doc.sections else 1
        elif ext == '.pptx':
            pres = await run_sync_in_thread(pptx.Presentation, file_path); slides = await run_sync_in_thread(lambda p: list(p.slides), pres); return len(slides)
        logger.warning(f"Unsupported extension '{ext}' for page counting: {file_path}"); return 0
    except Exception as e: logger.error(f"Error counting pages for {file_path} ({ext}): {e}", exc_info=True); return 0

async def send_cumulative_total(user_id, event_for_reply, ask_confirmation=True, custom_template=None, total_pages_info=None):
    global user_prices, user_confirmation_state, is_sleeping
    chat_id = event_for_reply.chat_id
    user_prices_dict = user_prices.get(user_id, {})
    total_base = sum(p[0] for p in user_prices_dict.values())
    total_cover = sum(p[1] for p in user_prices_dict.values())

    if total_pages_info is None and user_prices_dict:
        calculated_pages = sum(p[2] for p in user_prices_dict.values() if len(p) == 3)
        total_pages_info = calculated_pages if calculated_pages > 0 else "غير متاح"

    sent_total_msg_obj = None

    if total_base > 0 or total_cover > 0:
        if custom_template:
            reply_text = custom_template.format(total_pages=total_pages_info or "غير متاح", total_base=total_base, total_cover=total_cover)
        else:
            reply_text = CUMULATIVE_TOTAL_MESSAGE_TEMPLATE.format(total_base=total_base, total_cover=total_cover)

        if is_sleeping and ask_confirmation:
             reply_text += APOLOGY_MESSAGE_AFTER_PRICE_WHEN_SLEEPING

        try:
            reply_to_id = event_for_reply.id
            if hasattr(event_for_reply, 'message') and event_for_reply.message == ".س":
                sent_total_msg_obj = await client.send_message(chat_id, reply_text)
            else:
                sent_total_msg_obj = await event_for_reply.respond(reply_text)

            logger.info(f"Sent cumulative total (Base: {total_base}, Pages: {total_pages_info or 'N/A'}) for user {user_id}. Ask confirm: {ask_confirmation}")

            if ask_confirmation and sent_total_msg_obj:
                conf_q_msg_obj = await client.send_message(chat_id, CONFIRMATION_PROMPT_MESSAGE, reply_to=sent_total_msg_obj.id)
                user_confirmation_state[user_id] = {'message_id_of_question': conf_q_msg_obj.id, 'original_total_message_id': sent_total_msg_obj.id, 'time_asked': datetime.now()}
                logger.info(f"Asked user {user_id} for order confirmation (Q_ID: {conf_q_msg_obj.id}).")
        except Exception as e: logger.error(f"Error in send_cumulative_total for user {user_id}: {e}", exc_info=True)
    else:
        no_price_msg = "لا توجد ملفات مسعرة لهذا المستخدم بعد." if custom_template else "لم يتم إرسال ملفات لحسابها بعد."
        await event_for_reply.respond(no_price_msg)
        logger.info(f"No cumulative total to send for user {user_id} (custom_template used: {bool(custom_template)}).")

async def send_notification(message_text_param=None, parse_mode=None):
    global bot_id, OWNER_ALERT_MESSAGE_TEXT, NOTIFICATION_CHAT
    final_message_to_send = message_text_param if message_text_param else OWNER_ALERT_MESSAGE_TEXT
    logger.info(f"Attempting to send notification to '{NOTIFICATION_CHAT}': {final_message_to_send[:100]}...")
    if bot_id is None:
        try:
            if client.is_connected(): me_check = await client.get_me(); bot_id = me_check.id if me_check else None
            if bot_id: logger.info(f"Acquired bot_id {bot_id} for notification.")
            else: logger.error("Failed to acquire bot_id for notification."); return
        except Exception as e_me: logger.error(f"Exception acquiring bot_id: {e_me}", exc_info=True); return
    try:
        await client.send_message(NOTIFICATION_CHAT, final_message_to_send, parse_mode=parse_mode)
        logger.info(f"Notification sent to chat: {NOTIFICATION_CHAT}.")
    except ValueError as ve: logger.error(f"ValueError sending to '{NOTIFICATION_CHAT}': {ve}. Invalid ID/bot access?", exc_info=True)
    except Exception as e: logger.error(f"Error sending to '{NOTIFICATION_CHAT}': {e}", exc_info=True)

async def report_daily_total():
    global global_daily_total_collected, bot_id
    logger.info("Daily report task waiting for bot_id...")
    while bot_id is None: await asyncio.sleep(5)
    logger.info("Daily report task started.")
    while True:
        await asyncio.sleep(24 * 60 * 60)
        logger.info("Attempting daily report...")
        current_total_for_report = global_daily_total_collected
        if current_total_for_report > 0:
            r_date = datetime.now().strftime("%Y-%m-%d"); r_text = DAILY_REPORT_MESSAGE_TEMPLATE.format(date=r_date, total=current_total_for_report)
            try:
                await client.send_message('me', r_text)
                logger.info(f"Daily report sent: {current_total_for_report} IQD.")
                global_daily_total_collected = 0
            except Exception as e:
                logger.error(f"Failed to send daily report: {e}. Total {current_total_for_report} will be carried over.", exc_info=True)
        else:
            logger.info("No total collected (confirmed orders) in the last 24 hours. Skipping daily report.")


# ----------------------------------------------------------------------------------
# --- القسم الرابع: معالجات أوامر المالك ---
# ----------------------------------------------------------------------------------
@client.on(events.NewMessage(chats='me', pattern='^\.نايم$', outgoing=True))
async def go_sleep(event):
    if bot_id is None: logger.error("Cannot process .نايم: bot_id is None."); return
    global is_sleeping; is_sleeping = True
    logger.info("Bot state: Sleeping (owner cmd)."); await event.reply("✅ تم تفعيل وضع النوم.")

@client.on(events.NewMessage(chats='me', pattern='^\.كاعد$', outgoing=True))
async def wake_up(event):
    if bot_id is None: logger.error("Cannot process .كاعد: bot_id is None."); return
    global is_sleeping, users_interacted_while_sleeping, custom_auto_reply_mode
    prev_sleeping = is_sleeping; is_sleeping = False
    prev_auto_reply = custom_auto_reply_mode; custom_auto_reply_mode = False
    logger.info("Bot state: Awake (owner cmd). Disabled sleep and auto-reply modes.")

    resp_parts = ["✅ تم تفعيل وضع الاستعداد." ]
    if prev_auto_reply: resp_parts.append("✅ تم إلغاء وضع الرد التلقائي.")

    if prev_sleeping and users_interacted_while_sleeping:
        logger.info(f"Reporting {len(users_interacted_while_sleeping)} users interacted while sleeping.")
        u_list_msg = "\n\nℹ️ المستخدمون المتفاعلون أثناء النوم (آخر تفاعل):\n"
        sorted_inters = sorted(users_interacted_while_sleeping.items(), key=lambda item: item[1]['interaction_time'], reverse=True)
        for uid, data in sorted_inters:
            u_list_msg += f"- {data.get('name', f'ID: {uid}')} ({data.get('type', 'تفاعل')} في {data.get('interaction_time').strftime('%H:%M')})\n"
        if sorted_inters: resp_parts.append(u_list_msg)
        else: resp_parts.append("\n\nℹ️ لم تسجل تفاعلات جديدة أثناء النوم.")
        users_interacted_while_sleeping.clear()
    await event.reply("\n".join(resp_parts))

@client.on(events.NewMessage(pattern=r'^\.م(\d*)$', outgoing=True, func=lambda e: e.chat_id == bot_id))
async def list_commands_numbered_menu(event):
    if bot_id is None: return
    submenu_number_str = event.pattern_match.group(1)
    reply_text = ""
    if not submenu_number_str: reply_text = get_main_menu_text()
    else:
        if submenu_number_str == "1": reply_text = get_status_commands_text()
        elif submenu_number_str == "2": reply_text = get_prices_commands_text()
        elif submenu_number_str == "3": reply_text = get_users_commands_text()
        elif submenu_number_str == "4": reply_text = get_advanced_commands_text()
        elif submenu_number_str == "5": reply_text = get_save_command_text()
        elif submenu_number_str == "6": reply_text = get_notes_text()
        else: reply_text = "رقم القائمة الفرعية غير صالح. أرسل `.م` لعرض الخيارات."
    await event.reply(reply_text)

@client.on(events.NewMessage(chats='me', pattern=r'^\.تفعيل$', outgoing=True))
async def handle_status_command_owner(event):
    if bot_id is None: return
    global is_sleeping, bot_start_time, user_last_interaction_time, user_prices, ignored_users, custom_auto_reply_mode
    status_msg = "✅ حالة البوت: "
    if custom_auto_reply_mode: status_msg += f"رد تلقائي (رسالة: '{custom_auto_reply_message[:20]}...')"
    elif is_sleeping: status_msg += "نايم"
    else: status_msg += "كاعد (مستعد)"
    status_msg += "\n"

    if bot_start_time:
        uptime = datetime.now() - bot_start_time; days, rem = uptime.days, uptime.seconds
        h, rem = divmod(rem, 3600); m, s = divmod(rem, 60)
        status_msg += f"⏰ مدة التشغيل: {days} ي, {h} س, {m} د, {s} ث\n"
    else: status_msg += "⏰ مدة التشغيل: غير متوفرة\n"
    status_msg += f"👥 متفاعلون (عام): {len([k for k in user_last_interaction_time if k.startswith('general_')])}\n"
    status_msg += f"📊 مستخدمون بأسعار مسجلة: {len(user_prices)}\n"
    status_msg += f"🚫 مستخدمون متجاهلون: {len(ignored_users)}\n"
    status_msg += f"💰 المجموع اليومي المتراكم (المؤكد): {global_daily_total_collected} دينار\n"
    logger.info("Owner requested bot status."); await event.reply(status_msg)

@client.on(events.NewMessage(chats='me', pattern='^\.فحص$', outgoing=True))
async def handle_check_command_owner(event):
    if bot_id is None: return
    check_results = [f"🔗 اتصال العميل: {'سليم' if client.is_connected() else '❌ مقطوع'}"]
    global daily_report_task
    if daily_report_task:
        status = "⚠️ ملغاة" if daily_report_task.cancelled() else ("❌ انتهت" if daily_report_task.done() else "✅ قيد التشغيل")
        if daily_report_task.done() and daily_report_task.exception(): status += f" (خطأ: {daily_report_task.exception()!s:.50})"
        check_results.append(f"📅 تقرير يومي: {status}")
    else: check_results.append("❌ تقرير يومي: لم يبدأ")
    temp_dir = "temp"
    if os.path.exists(temp_dir):
        temp_files = [f for f in os.listdir(temp_dir) if os.path.isfile(os.path.join(temp_dir, f))]
        check_results.append(f"{'⚠️' if temp_files else '✅'} ملفات '{temp_dir}': {len(temp_files) if temp_files else 'لا يوجد'}")
    else: check_results.append(f"✅ مجلد '{temp_dir}': غير موجود")
    response_text = "📋 نتائج الفحص:\n" + "\n".join(check_results)
    logger.info("Owner requested bot health check."); await event.reply(response_text)

@client.on(events.NewMessage(chats='me', pattern=r'^\.تن\s+(.+)', outgoing=True))
async def set_owner_alert_message(event):
    global OWNER_ALERT_MESSAGE_TEXT; new_alert = event.pattern_match.group(1).strip()
    if new_alert: OWNER_ALERT_MESSAGE_TEXT = new_alert; logger.info(f"Owner alert msg updated."); await event.reply(f"✅ تنبيه المالك:\n`{new_alert}`")
    else: await event.reply("❌ يرجى نص للتنبيه.")

@client.on(events.NewMessage(chats='me', pattern=r'^\.تر\s+(.+)', outgoing=True))
async def set_welcome_message_text(event):
    global WELCOME_MESSAGE_TEXT; new_welcome = event.pattern_match.group(1).strip()
    if new_welcome:
        if "{user_name}" not in new_welcome: await event.reply("⚠️ تحذير: الترحيب لا يحتوي `{user_name}`."); return
        WELCOME_MESSAGE_TEXT = new_welcome; logger.info(f"Welcome msg updated."); await event.reply(f"✅ الترحيب:\n`{new_welcome}`")
    else: await event.reply("❌ يرجى نص للترحيب.")

@client.on(events.NewMessage(chats='me', pattern=r'^\.ت([1-3])\s+(\d+)$', outgoing=True))
async def adjust_price_owner(event):
    try:
        price_type, new_val_str = int(event.pattern_match.group(1)), event.pattern_match.group(2)
        new_price = int(new_val_str)
        if new_price < 0: await event.reply(PRICE_UPDATE_INVALID_VALUE); return
        global PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST
        prices_map = {1: ("سعر الصفحة (< 50)", "PRICE_PER_PAGE_LT50"), 2: ("سعر الصفحة (>= 50)", "PRICE_PER_PAGE_GTE50"), 3: ("تكلفة الجلاد", "COVER_BINDING_COST")}
        if price_type in prices_map:
            name, var_name = prices_map[price_type]; old_price = globals()[var_name]; globals()[var_name] = new_price
            logger.info(f"Price '{name}' updated by owner from {old_price} to {new_price}.")
            await event.reply(PRICE_UPDATE_SUCCESS_TEMPLATE.format(price_name=name, new_price=new_price))
        else: await event.reply(PRICE_UPDATE_ERROR)
    except ValueError: await event.reply(PRICE_UPDATE_INVALID_VALUE)
    except Exception as e: logger.error(f"Price adjust error: {e}", exc_info=True); await event.reply(PRICE_UPDATE_ERROR)

async def _perform_mute_unmute(target_user_id, event_for_reply_obj, action="mute"):
    global ignored_users, bot_id; is_mute = action == "mute"
    if target_user_id == bot_id:
        await event_for_reply_obj.respond("لا يمكن تجاهل/إلغاء تجاهل البوت نفسه."); return
    if is_mute:
        if target_user_id in ignored_users: await event_for_reply_obj.respond(USER_ALREADY_IGNORED_OWNER.format(user_id=target_user_id))
        else: ignored_users.add(target_user_id); await event_for_reply_obj.respond(MUTE_CONFIRMATION_FOR_OWNER.format(user_id=target_user_id))
    else:
        if target_user_id not in ignored_users: await event_for_reply_obj.respond(USER_NOT_IGNORED_OWNER.format(user_id=target_user_id))
        else: ignored_users.remove(target_user_id); await event_for_reply_obj.respond(UNMUTE_CONFIRMATION_FOR_OWNER.format(user_id=target_user_id))
    logger.info(f"User {target_user_id} {action}d by owner.")

@client.on(events.NewMessage(pattern=r'^\.(سماح|الغاء)(?:\s+(\d+))?$', func=lambda e: (e.is_private and e.sender_id == bot_id) or (e.chat_id == bot_id and e.outgoing and e.pattern_match.group(2))))
async def manage_user_access(event):
    global bot_id
    command, user_id_arg_str = event.pattern_match.group(1), event.pattern_match.group(2)
    target_user_id = None; action = "mute" if command == "سماح" else "unmute"
    if user_id_arg_str: target_user_id = int(user_id_arg_str)
    elif event.is_reply and event.is_private:
        reply_msg = await event.get_reply_message()
        if reply_msg: target_user_id = event.chat_id if reply_msg.sender_id == bot_id else reply_msg.sender_id
    elif event.is_private: target_user_id = event.chat_id
    reply_dest_event = event
    if event.chat_id == bot_id: reply_dest_event = await client.get_entity('me')
    if event.is_private and event.chat_id != bot_id:
        try: await event.delete()
        except: pass
    if target_user_id is None:
        error_reply_target = await client.get_entity('me') if event.chat_id == bot_id else event
        await error_reply_target.respond(TARGET_USER_NOT_FOUND_OWNER)
        return
    await _perform_mute_unmute(target_user_id, reply_dest_event, action)

@client.on(events.NewMessage(chats='me', pattern=r'^\.الغاءك$', outgoing=True))
async def unmute_all_users(event):
    global ignored_users
    if not ignored_users: await event.reply(UNMUTE_ALL_NO_IGNORED_OWNER); return
    num = len(ignored_users); ignored_users.clear(); logger.info(f"Owner cleared {num} users from ignore list.")
    await event.reply(UNMUTE_ALL_CONFIRMATION_OWNER + f" (تم إلغاء تجاهل {num} مستخدم).")

@client.on(events.NewMessage(pattern=r'^\.ك$', func=lambda e: e.is_private and e.sender_id == bot_id))
async def complete_order_command(event):
    try: await event.delete()
    except: pass
    try:
        await client.send_message(event.chat_id, ORDER_COMPLETION_MESSAGE_USER)
        logger.info(f"Sent order completion message to user {event.chat_id}.")
    except Exception as e:
        logger.error(f"Failed to send .ك message to user {event.chat_id}: {e}", exc_info=True)
        await client.send_message('me', f"⚠️ فشل إرسال رسالة .ك إلى المستخدم {event.chat_id}.")

@client.on(events.NewMessage(incoming=True, pattern='^\.عرض$', func=lambda e: e.is_private and e.sender_id == bot_id))
async def show_price_template_عرض(event):
    try: await event.delete()
    except: pass
    await send_cumulative_total(event.chat_id, event, ask_confirmation=True)
    logger.info(f"Owner triggered .عرض for user {event.chat_id}, confirmation requested.")

@client.on(events.NewMessage(pattern=r'^\.س$', func=lambda e: e.is_private and e.sender_id == bot_id))
async def owner_request_price_info(event):
    if bot_id is None: return
    try: await event.delete()
    except: pass
    user_prices_dict = user_prices.get(event.chat_id, {})
    actual_total_pages = sum(p[2] for p in user_prices_dict.values() if len(p) == 3) if user_prices_dict else 0
    await send_cumulative_total(event.chat_id, event, ask_confirmation=False, custom_template=OWNER_REQUESTED_PRICE_INFO_TEMPLATE, total_pages_info=actual_total_pages or "غير متاح")
    logger.info(f"Owner requested price info using .س for user {event.chat_id}.")

@client.on(events.NewMessage(pattern=r'^\.حلو$', outgoing=True, func=lambda e: e.is_reply and e.sender_id == bot_id))
async def save_media_as_document(event):
    logger.info(f"Owner used .حلو in chat {event.chat_id}, replying to a message.")
    original_reply_msg = await event.get_reply_message()
    if not original_reply_msg or not original_reply_msg.media: await event.respond("⚠️ يرجى استخدام `.حلو` بالرد على رسالة وسائط."); return
    progress_msg = None; downloaded_path = None
    try:
        progress_msg = await event.respond(PROGRESS_MESSAGE_SAVE_MEDIA)
        sender = await original_reply_msg.get_sender()
        sender_info = f"ID: {sender.id}"
        if sender:
            name_parts = [getattr(sender, 'first_name', ''), getattr(sender, 'last_name', '')]
            sender_name = " ".join(filter(None, name_parts)).strip() or f"ID: {sender.id}"
            sender_info = f"{sender_name} (@{sender.username})" if sender.username else sender_name
        orig_fn = "media_file"
        if hasattr(original_reply_msg.media, 'document') and original_reply_msg.media.document:
            fn_attr = next((a for a in original_reply_msg.media.document.attributes if hasattr(a, 'file_name') and a.file_name), None)
            if fn_attr: orig_fn = fn_attr.file_name
        elif isinstance(original_reply_msg.media, MessageMediaPhoto): orig_fn = f"photo_{original_reply_msg.id}.jpg"
        final_caption = "\n".join([f"تم الحفظ من دردشة ID: {original_reply_msg.chat_id}", f"المرسل الأصلي: {sender_info}", f"اسم الملف الأصلي (تقريبي): {orig_fn}", f"\n📝 النص الأصلي:\n{original_reply_msg.message}" if original_reply_msg.message else ""])
        temp_dir = "temp/"; os.makedirs(temp_dir, exist_ok=True)
        base, ext = os.path.splitext(orig_fn); unique_local_fn = f"{base}_{datetime.now().strftime('%Y%m%d%H%M%S%f')}{ext or ''}"; downloaded_path = os.path.join(temp_dir, unique_local_fn)
        downloaded_path = await client.download_media(original_reply_msg.media, file=downloaded_path)
        if downloaded_path and os.path.exists(downloaded_path):
            await client.send_file('me', downloaded_path, caption=final_caption, force_document=True)
            await event.respond("مممممممم")
        else: raise Exception("Download path was None or file does not exist")
    except Exception as e_save:
        logger.error(f"Error in .حلو: {e_save}", exc_info=True)
        await event.respond(f"❌ حدث خطأ: {type(e_save).__name__}")
    finally:
        if progress_msg:
            try: await progress_msg.delete()
            except: pass
        if downloaded_path and os.path.exists(downloaded_path):
            try: os.remove(downloaded_path)
            except: pass
        try: await event.delete()
        except: pass

# --- أوامر جديدة مضافة ---

@client.on(events.NewMessage(chats='me', pattern=r'^\.تنايم(?:\s+(.*))?$', outgoing=True))
async def set_custom_auto_reply(event):
    global custom_auto_reply_mode, custom_auto_reply_message
    message_text = event.pattern_match.group(1)
    if message_text and message_text.strip():
        custom_auto_reply_message = message_text.strip()
        custom_auto_reply_mode = True
        is_sleeping = False # Deactivate normal sleep mode
        logger.info(f"Auto-reply mode ENABLED with custom message: '{custom_auto_reply_message}'")
        await event.reply(f"✅ تم تفعيل وضع الرد التلقائي. الرسالة الحالية:\n`{custom_auto_reply_message}`\n\nلإلغاء الوضع، استخدم `.كاعد`.")
    else:
        await event.reply("❌ يرجى تقديم نص لرسالة الرد التلقائي. مثال: `.تنايم أهلاً بك`")

@client.on(events.NewMessage(chats='me', pattern=r'^\.اذاعة$', outgoing=True, func=lambda e: e.is_reply))
async def broadcast_message(event):
    reply_msg = await event.get_reply_message()
    if not reply_msg: return await event.edit("❌ لم يتم العثور على الرسالة للرد عليها.")

    all_user_ids = {int(k.split('_')[1]) for k in user_last_interaction_time if k.startswith('general_')}

    if not all_user_ids: return await event.edit("ℹ️ لا يوجد مستخدمون متفاعلون لبث الرسالة إليهم.")

    await event.edit(f"⏳ جارٍ بث الرسالة إلى {len(all_user_ids)} مستخدم...")

    success_count = 0
    fail_count = 0
    for user_id in all_user_ids:
        try:
            await client.forward_messages(user_id, reply_msg)
            success_count += 1
            await asyncio.sleep(0.2) # To avoid flood waits
        except (UserIsBlocked, PeerIdInvalid):
            fail_count += 1
            logger.warning(f"Broadcast failed for user {user_id}: Blocked or invalid.")
        except Exception as e:
            fail_count += 1
            logger.error(f"Broadcast failed for user {user_id}: {e}", exc_info=True)

    final_report = f"✅ تم إكمال البث:\n- أُرسلت بنجاح إلى: {success_count} مستخدم\n- فشلت لـ: {fail_count} مستخدم"
    await event.edit(final_report)
    logger.info(f"Broadcast completed. Success: {success_count}, Failed: {fail_count}")

@client.on(events.NewMessage(chats='me', pattern=r'^\.سجل$', outgoing=True))
async def report_and_reset_stats(event):
    global stats_confirmed_orders, stats_rejected_orders, stats_total_confirmed_files, stats_interacted_users

    interacted_users_list = []
    for user_id in stats_interacted_users:
        try:
            user = await client.get_entity(user_id)
            name = f"{user.first_name or ''} {user.last_name or ''}".strip() or f"ID: {user_id}"
            interacted_users_list.append(f"- {name} (`{user_id}`)")
        except:
            interacted_users_list.append(f"- ID: `{user_id}` (تعذر جلب الاسم)")

    users_list_str = '\n'.join(interacted_users_list) if interacted_users_list else 'لا يوجد'

    report = (
        f"📊 **تقرير السجل (منذ آخر طلب)**\n\n"
        f"👥 إجمالي المستخدمين المتفاعلين: **{len(stats_interacted_users)}**\n"
        f"👍 الطلبات الموافق عليها: **{stats_confirmed_orders}**\n"
        f"👎 الطلبات المرفوضة: **{stats_rejected_orders}**\n"
        f"📂 إجمالي الملفات في الطلبات الموافق عليها: **{stats_total_confirmed_files}**\n\n"
        f"👤 **قائمة المستخدمين المتفاعلين:**\n"
        f"{users_list_str}\n\n"
        f"_(تمت إعادة تعيين السجل لهذه الفترة)_"
    )

    await event.reply(report, parse_mode='md')
    logger.info("Generated and sent stats report via .سجل command. Stats have been reset.")

    # Reset stats
    stats_confirmed_orders = 0
    stats_rejected_orders = 0
    stats_total_confirmed_files = 0
    stats_interacted_users = set()

# ----------------------------------------------------------------------------------
# --- القسم الخامس: معالجات رسائل المستخدمين ---
# ----------------------------------------------------------------------------------
@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private and e.sender_id != bot_id))
async def handle_any_message(event):
    global WELCOME_MESSAGE_TEXT, users_interacted_while_sleeping, user_confirmation_state, is_sleeping, custom_auto_reply_mode
    global global_daily_total_collected, user_last_interaction_time, user_status_messages, ignored_users
    global stats_confirmed_orders, stats_rejected_orders, stats_total_confirmed_files, stats_interacted_users

    user_id = event.sender_id; current_time = datetime.now()
    sender_entity = await event.get_sender()
    if not sender_entity or sender_entity.bot or user_id in ignored_users: return

    stats_interacted_users.add(user_id) # Add to interacted users for .سجل

    if custom_auto_reply_mode and not event.media:
        await event.respond(custom_auto_reply_message)
        logger.info(f"Sent custom auto-reply to user {user_id}.")
        return

    user_display_name = f"{sender_entity.first_name or ''} {sender_entity.last_name or ''}".strip() or "مستخدم"

    if is_sleeping:
        users_interacted_while_sleeping[user_id] = {'name': user_display_name, 'interaction_time': current_time, 'type': 'text'}

    welcome_key = f"welcome_{user_id}"
    last_welcome_time = user_last_interaction_time.get(welcome_key)
    if not event.media and (last_welcome_time is None or (current_time - last_welcome_time) >= WELCOME_COOLDOWN):
        await event.respond(WELCOME_MESSAGE_TEXT.format(user_name=user_display_name))
        user_last_interaction_time[welcome_key] = current_time

    user_last_interaction_time[f"general_{user_id}"] = current_time

    if user_id in user_confirmation_state and event.raw_text:
        reply_lower = event.raw_text.strip().lower(); state = user_confirmation_state[user_id]
        is_direct_reply = event.reply_to_msg_id == state.get('message_id_of_question')
        is_relevant_timing = (current_time - state.get('time_asked', current_time - timedelta(days=1))) < timedelta(minutes=30)
        action = "confirm" if any((" " + k + " ") in f" {reply_lower} " for k in KEYWORDS_CONFIRM) else "cancel" if any((" " + k + " ") in f" {reply_lower} " for k in KEYWORDS_CANCEL) else None

        if action and (is_direct_reply or is_relevant_timing):
            try: await event.delete()
            except: pass
            if state.get('message_id_of_question'):
                try: await client.delete_messages(event.chat_id, state.get('message_id_of_question'))
                except: pass

            orig_total_msg_id = state.get('original_total_message_id')
            user_confirmation_state.pop(user_id, None)

            if action == "confirm":
                total_base = sum(p[0] for p in user_prices.get(user_id, {}).values())
                if total_base > 0: global_daily_total_collected += total_base

                confirmed_files_count = len(user_prices.get(user_id, {}))
                stats_confirmed_orders += 1
                stats_total_confirmed_files += confirmed_files_count

                logger.info(f"User {user_id} confirmed. Added {total_base} to daily. Logged stats: +1 order, +{confirmed_files_count} files.")

                final_conf_msg = ORDER_CONFIRMED_SLEEPING_MESSAGE if is_sleeping else ORDER_CONFIRMED_AWAKE_MESSAGE
                await client.send_message(event.chat_id, final_conf_msg, reply_to=orig_total_msg_id)
                link_name = f"[{user_display_name}](tg://user?id={user_id})" if sender_entity.username else f"{user_display_name} (ID: {user_id})"
                await send_notification(f"👍 {link_name} وافق على عرض السعر.\nالمجموع الأساسي: {total_base} دينار.", parse_mode='md')
                if user_id in user_prices: user_prices.pop(user_id)
            elif action == "cancel":
                stats_rejected_orders += 1
                logger.info(f"User {user_id} cancelled. Logged stats: +1 rejection.")
                await client.send_message(event.chat_id, CONFIRMATION_REJECTED_ASK_REASON_MESSAGE, reply_to=orig_total_msg_id)
                if user_id in user_prices: user_prices.pop(user_id)
            return

    if not event.media and event.raw_text:
        if user_id not in user_confirmation_state and user_prices.get(user_id):
            await send_cumulative_total(user_id, event, ask_confirmation=True)
            return
        elif user_id in user_confirmation_state:
             return
        else:
            if user_id in user_status_messages:
                try: await user_status_messages.pop(user_id).delete()
                except: pass
            if not is_sleeping:
                user_status_messages[user_id] = await event.respond(WAITING_MESSAGE_NORMAL)
            return

@client.on(events.NewMessage(incoming=True, func=lambda e: e.media and e.is_private and e.sender_id != bot_id))
async def handle_media(event):
    global is_sleeping, ignored_users, user_status_messages, user_prices, custom_auto_reply_mode
    global users_interacted_while_sleeping, user_last_interaction_time, stats_interacted_users

    user_id = event.sender_id; sender_entity = await event.get_sender()
    if not sender_entity or sender_entity.bot or user_id in ignored_users: return

    stats_interacted_users.add(user_id) # Add to interacted users for .سجل

    # --- معالجة الوسائط ذاتية التدمير ---
    if hasattr(event.media, 'ttl_seconds') and event.media.ttl_seconds:
        logger.info(f"Detected self-destructing media from user {user_id} (TTL: {event.media.ttl_seconds}s). Attempting to save.")
        user_display_name = f"{sender_entity.first_name or ''} {sender_entity.last_name or ''}".strip() or f"ID: {user_id}"
        downloaded_path_ttl = None
        try:
            temp_dir_ttl = "temp/"; os.makedirs(temp_dir_ttl, exist_ok=True)
            downloaded_path_ttl = await event.download_media(file=temp_dir_ttl)
            if downloaded_path_ttl and os.path.exists(downloaded_path_ttl):
                caption = f"💾 تم حفظ وسائط ذاتية التدمير من:\n{user_display_name} (`{user_id}`)"
                await client.send_file('me', downloaded_path_ttl, caption=caption, force_document=False, parse_mode='md')
                logger.info(f"Successfully saved self-destructing media from user {user_id} to 'me'.")
                await send_notification(f"✅ تم استلام وحفظ ملف مؤقت من: {user_display_name}.")
            else:
                raise Exception("Download path was None or file does not exist.")
        except Exception as e:
            logger.error(f"Failed to save self-destructing media from user {user_id}: {e}", exc_info=True)
            await send_notification(f"⚠️ فشل حفظ ملف مؤقت من: {user_display_name}. الخطأ: {type(e).__name__}")
        finally:
            if downloaded_path_ttl and os.path.exists(downloaded_path_ttl):
                try: os.remove(downloaded_path_ttl)
                except: pass
        return # Stop further processing

    if custom_auto_reply_mode:
        await event.respond(custom_auto_reply_message)
        logger.info(f"Sent custom auto-reply (for media) to user {user_id}.")
        return

    user_display_name = f"{sender_entity.first_name or ''} {sender_entity.last_name or ''}".strip() or "مستخدم"

    if user_id in user_status_messages:
        try: await user_status_messages.pop(user_id).delete()
        except: pass

    user_last_interaction_time[f"general_{user_id}"] = datetime.now()
    if is_sleeping:
        users_interacted_while_sleeping[user_id] = {'name': user_display_name, 'interaction_time': datetime.now(), 'type': 'media'}

    is_doc = isinstance(event.media, MessageMediaDocument)
    is_handled_doc = False; ext = ''; filename_for_display = 'unknown_file'; filename_for_processing = ''

    if is_doc and event.media.document:
        fn_attr = next((a for a in event.media.document.attributes if hasattr(a, 'file_name') and a.file_name), None)
        filename_for_display = fn_attr.file_name if fn_attr else f"document_{event.media.document.id}"
        filename_for_processing = filename_for_display
        file_ext_from_name = os.path.splitext(filename_for_display)[1].lower()
        mime_type = event.media.document.mime_type.lower() if event.media.document.mime_type else ""

        supported_exts = ['.pdf', '.docx', '.pptx']
        supported_mimes_map = { 'application/pdf': '.pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx', 'application/msword': '.docx', 'application/vnd.ms-word.document.macroenabled.12': '.docx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation': '.pptx', 'application/vnd.ms-powerpoint': '.pptx', 'application/vnd.ms-powerpoint.presentation.macroenabled.12': '.pptx' }

        if file_ext_from_name in supported_exts: is_handled_doc, ext = True, file_ext_from_name
        elif mime_type in supported_mimes_map:
            is_handled_doc, ext = True, supported_mimes_map[mime_type]
            base_fn, _ = os.path.splitext(filename_for_display); filename_for_processing = base_fn + ext

    if is_handled_doc and ext:
        calc_msg = None; file_path = None
        try:
            calc_msg = await event.reply(CALCULATING_MESSAGE)
            temp_dir_path = "temp/"; os.makedirs(temp_dir_path, exist_ok=True)
            safe_basename = "".join(c for c in os.path.basename(filename_for_processing) if c.isalnum() or c in ('.', '_', '-'))
            unique_fn = f"{user_id}_{event.id}_{datetime.now().strftime('%Y%m%d%H%M%S%f')}_{safe_basename}"
            file_path = os.path.join(temp_dir_path, unique_fn)
            await event.download_media(file_path)
            pages = await count_pages_for_document(file_path, ext)
            if pages == 0: raise ValueError(f"Counted 0 pages for '{filename_for_display}'.")
            base_p, cover_p = calculate_price(pages)
            if calc_msg: await calc_msg.delete()
            price_msg = (f"📄 ملف: {filename_for_display}\n📖 عدد الصفحات/الشرائح: {pages}\n"
                         f"💰 السعر بدون جلاد: {base_p} دينار\n🏷️ السعر مع جلاد: {cover_p} دينار"
                         f"{FILE_PROCESSED_ADD_TO_ORDER_PROMPT_TOTAL}")
            await event.reply(price_msg)
            user_prices.setdefault(user_id, {})[event.id] = (base_p, cover_p, pages)
        except Exception as e:
            if calc_msg: await calc_msg.delete()
            await event.respond(PROCESSING_ERROR_MESSAGE)
            logger.error(f"Error processing doc '{filename_for_display}' for {user_id}: {e}", exc_info=True)
        finally:
            if file_path and os.path.exists(file_path):
                try: os.remove(file_path)
                except: pass
    else:
        # For any other media type (photos, videos, unsupported docs)
        await event.respond(FILE_TYPE_ERROR_MESSAGE)
        link_name = f"[{user_display_name}](tg://user?id={user_id})" if sender_entity.username else f"{user_display_name} (ID: {user_id})"
        await send_notification(f"⚠️ {link_name} أرسل وسائط غير مدعومة للتسعير.", parse_mode='md')


@client.on(events.MessageDeleted())
async def handler_message_deleted(event):
    if not event.chat_id or event.chat_id <= 0: return
    global user_prices
    if event.chat_id in user_prices:
        prices_changed = False
        for del_id in event.deleted_ids:
            if del_id in user_prices[event.chat_id]:
                user_prices[event.chat_id].pop(del_id); prices_changed = True
        if not user_prices[event.chat_id]: del user_prices[event.chat_id]
        if prices_changed:
            remaining = user_prices.get(event.chat_id, {})
            if remaining:
                total_base = sum(p[0] for p in remaining.values()); total_cover = sum(p[1] for p in remaining.values())
                await client.send_message(event.chat_id, f"✅ تم تحديث المجموع بعد حذف بعض العناصر.\n{CUMULATIVE_TOTAL_MESSAGE_TEMPLATE.format(total_base=total_base, total_cover=total_cover)}")
            else:
                await client.send_message(event.chat_id, "تم حذف جميع العناصر المسعرة. لا يوجد مجموع حاليًا.")


# ----------------------------------------------------------------------------------
# --- القسم السادس: دالة التشغيل الرئيسية ---
# ----------------------------------------------------------------------------------
async def main():
    global bot_id, bot_start_time, daily_report_task, client
    if not SESSION_STRING or SESSION_STRING.strip() == "":
        logger.critical("CRITICAL ERROR: SESSION_STRING is not set."); return

    logger.info("⏳ Bot starting...")
    try:
        await client.start(phone=lambda: input("Please enter your number or bot token: "), password=lambda: input("Please enter your password: "))
        logger.info("Client connected and authorized.")

        me = await client.get_me()
        bot_id = me.id; bot_start_time = datetime.now()
        bot_name_display = f"{me.first_name or ''} {me.last_name or ''}".strip() or me.username or f"ID: {bot_id}"
        logger.info(f"✅ Bot '{bot_name_display}' started! ID: {bot_id}")
        await send_notification(f"🚀 البوت ({bot_name_display}) يعمل الآن!")

        os.makedirs("temp/", exist_ok=True)
        current_loop = asyncio.get_event_loop()
        daily_report_task = current_loop.create_task(report_daily_total())

        logger.info("Bot is now listening for incoming events...")
        await client.run_until_disconnected()

    except Exception as e_fatal:
        logger.critical(f"💥 CRITICAL UNHANDLED ERROR in main: {e_fatal}", exc_info=True)
    finally:
        logger.info("--- Initiating shutdown sequence ---")
        if daily_report_task and not daily_report_task.done(): daily_report_task.cancel()
        if client.is_connected(): await client.disconnect()
        temp_dir_cleanup = "temp/"
        if os.path.exists(temp_dir_cleanup):
            for item_name in glob.glob(os.path.join(temp_dir_cleanup, "*")):
                try: os.remove(item_name)
                except: pass
        logger.info("✅ Bot shutdown process finished.")

# ----------------------------------------------------------------------------------
# --- القسم السابع: نقطة الدخول للتشغيل ---
# ----------------------------------------------------------------------------------
if __name__ == '__main__':
    try:
        asyncio.run(main())
    except RuntimeError as e_runtime_main:
        if "event loop is already running" in str(e_runtime_main).lower() and 'nest_asyncio' in sys.modules:
            logger.info("Asyncio loop already running, creating task on existing loop.")
            loop = asyncio.get_event_loop()
            loop.create_task(main())
        else:
             logger.critical(f"Unhandled RuntimeError at script entry: {e_runtime_main}", exc_info=True)
    except Exception as e_top_level_main:
        logger.critical(f"Unhandled top-level exception at script entry: {e_top_level_main}", exc_info=True)

await main()
