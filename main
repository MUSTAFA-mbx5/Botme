# ==================================================================================
# ===   Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ - v63 (Configurable, Feature-Rich, Bug-Fixed with correct imports) ===
# ==================================================================================
# --- 1. Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---
import logging

logger = logging.getLogger("Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰")
logger.setLevel(logging.INFO)

stream_handler = logging.StreamHandler()
logger.addHandler(stream_handler)
from multiprocessing.connection import Client
import os
import sys
import asyncio
import logging
import traceback
import math
import random
import json
import configparser  # Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù„Ù config.ini
from datetime import datetime, timedelta, time 
from telethon import events
import time
import io

try:
    import fitz  # PyMuPDF
except ImportError:
    print("!!! ERROR: PyMuPDF (fitz) not found. Please install it: pip install PyMuPDF")
    sys.exit(1)

try:
    import docx  # python-docx
except ImportError:
    print("!!! ERROR: python-docx not found. Please install it: pip install python-docx")
    sys.exit(1)

try:
    import pptx  # python-pptx
except ImportError:
    print("!!! ERROR: python-pptx not found. Please install it: pip install python-pptx")
    sys.exit(1)

# --- Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø± ÙˆØ§Ù„Ù…Ù„Ù Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ ---
ENV_FOLDER = os.path.join("D:\\MyTelegramBot", "evn")
ENV_FILE_PATH = os.path.join(ENV_FOLDER, "env_variables.ini")

if not os.path.exists(ENV_FOLDER):
    os.makedirs(ENV_FOLDER)

if not os.path.exists(ENV_FILE_PATH):
    config = configparser.ConfigParser()
    config["TELEGRAM"] = {
        "API_ID": "",
        "API_HASH": "",
        "SESSION_STRING": "",
        "PRINTING_GROUP_ID": "",
        "PRINTER_NAME_1": "",
        "PRINTER_NAME_2": ""
    }
    with open(ENV_FILE_PATH, "w", encoding="utf-8") as configfile:
        config.write(configfile)
    print(f"[âœ…] ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª: {ENV_FILE_PATH}")
else:
    print(f"[â„¹ï¸] ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª: {ENV_FILE_PATH}")
# --- Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† env_variables.ini ---
config = configparser.ConfigParser()
config.read(ENV_FILE_PATH, encoding="utf-8")

# --- Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ---
API_ID = int(config.get("TELEGRAM", "API_ID", fallback="0"))
API_HASH = config.get("TELEGRAM", "API_HASH", fallback="")
SESSION_STRING = config.get("TELEGRAM", "SESSION_STRING", fallback="")
PRINTING_GROUP_ID = config.get("TELEGRAM", "PRINTING_GROUP_ID", fallback="")
PRINTER_NAME_1 = config.get("TELEGRAM", "PRINTER_NAME_1", fallback="")
PRINTER_NAME_2 = config.get("TELEGRAM", "PRINTER_NAME_2", fallback="")
# --- ØªØ¹Ø±ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù† client ---
from telethon import TelegramClient
from telethon.sessions import StringSession

async def main():
    client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)

async def main():
    await client.start()
    me = await client.get_me()
    owner_id = me.id
    bot_start_time = datetime.now()
    logger.info(f"âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† ÙƒÙ€ {me.first_name} [{me.id}]")

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")
        elif event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")

    await client.run_until_disconnected()

asyncio.run(main())


# --- Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù† ---
async def is_admin(event):
    if not event.is_group:
        return False
    participants = await event.client.get_participants(event.chat_id, filter=ChannelParticipantsAdmins) # pyright: ignore[reportUndefinedVariable]
    return any(user.id == event.sender_id for user in participants)
async def handler(event):
    pass
# --- Ù…ØªØºÙŠØ±Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ---
is_sleeping = False # Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª (Ù†Ø§Ø¦Ù… / Ù…Ø³ØªÙŠÙ‚Ø¸)
user_prices = {} # Ù„ØªØ®Ø²ÙŠÙ† Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚ØªØ©
user_status_messages = {} # Ù„ØªØ®Ø²ÙŠÙ† Ø±Ø³Ø§Ø¦Ù„ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
user_last_interaction_time = {} # Ù„ØªØ®Ø²ÙŠÙ† ÙˆÙ‚Øª Ø¢Ø®Ø± ØªÙØ§Ø¹Ù„ Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
ignored_users = set() # Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ØªÙ… ØªØ¬Ø§Ù‡Ù„Ù‡Ù…
bot_id = None # Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ø±Ù Ø§Ù„Ø¨ÙˆØª Ø¨Ø¹Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
global_daily_total_collected = 0 # Ù…ØªØºÙŠØ± Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
bot_start_time = None # Ù„ØªØ³Ø¬ÙŠÙ„ ÙˆÙ‚Øª Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
user_confirmation_state = {} # Ù„ØªØªØ¨Ø¹ Ø­Ø§Ù„Ø§Øª Ø§Ù„ØªØ£ÙƒÙŠØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
pending_print_jobs = {} # Ù„ØªØªØ¨Ø¹ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
all_known_users = set() # Ù„ØªØ®Ø²ÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ØªÙØ§Ø¹Ù„ÙˆØ§ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØª
owner_id = None # Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ø±Ù Ù…Ø§Ù„Ùƒ Ø§Ù„Ø¨ÙˆØª
ADMIN_IDS = set() # Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†

# --- Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ---
PRICE_PER_PAGE_LT50 = 50 # Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© Ù„Ø£Ù‚Ù„ Ù…Ù† 50 ØµÙØ­Ø©
PRICE_PER_PAGE_GTE50 = 40 # Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© Ù„Ù€ 50 ØµÙØ­Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±
COVER_BINDING_COST = 500 # ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©

# --- Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¨ÙˆØª ---
DEFAULT_WELCOME_MESSAGE = "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ {user_name} ÙÙŠ Ø¨ÙˆØª Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰! Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ù„Ù PDF, DOCX, Ø£Ùˆ PPTX ÙˆØ³Ø£Ù‚ÙˆÙ… Ø¨Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ùƒ."

CUMULATIVE_TOTAL_MESSAGE_TEMPLATE = (
    "ğŸ“Š Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†:\n"
    "Ø¨Ø¯ÙˆÙ† Ø¬Ù„Ø§Ø¯: {total_base} Ø¯ÙŠÙ†Ø§Ø±\n"
    "Ù…Ø¹ Ø¬Ù„Ø§Ø¯: {total_cover} Ø¯ÙŠÙ†Ø§Ø±"
)

ORDER_COMPLETION_MESSAGE_USER = (
    "âœ… ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­.\n"
    "ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªÙ„Ø§Ù…Ù‡ Ø£Ùˆ Ø·Ù„Ø¨ ØªÙˆØµÙŠÙ„ Ù…Ø¹ Ø°ÙƒØ± Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:\n"
    "- Ø§Ù„Ø§Ø³Ù…:\n"
    "- Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ:\n"
    "- Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø¯Ø§Ù„Ø©:\n\n"
    "Ø´ÙƒØ±Ù‹Ø§ Ù„Ø§Ø®ØªÙŠØ§Ø±Ù†Ø§."
)

# --- ÙƒÙ„Ù…Ø§Øª ØªØ³ØªØ®Ø¯Ù… Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø·Ù„Ø¨ ---
KEYWORDS_CONFIRM = [
    "Ù†Ø¹Ù…", "Ø§ÙŠ", "Ø£Ø¬Ù„", "Ù…ÙˆØ§ÙÙ‚", "Ù…ÙˆØ§ÙÙ‚Ø©", "yes", "ok",
    "confirm", "yep", "yeah", "ØªÙ…Ø§Ù…", "Ø§ÙˆÙƒÙŠ", "ÙˆÙƒ", "Ø§ÙˆÙƒ", "ØªÙ…"
]

# --- ÙƒÙ„Ù…Ø§Øª ØªØ³ØªØ®Ø¯Ù… Ù„Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ---
KEYWORDS_CANCEL = [
    "Ù„Ø§", "ÙƒÙ„Ø§", "Ø§Ø±ÙØ¶", "no", "cancel", "nope", "Ø§Ù„ØºØ§Ø¡"
]

# --- 6. Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ---

def is_admin(event):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±Ø³Ù„ Ø§Ù„Ø­Ø¯Ø« Ù‡Ùˆ Ù…Ø³Ø¤ÙˆÙ„."""
    return event.sender_id in ADMIN_IDS

def create_progress_bar(percentage):
    """ÙŠÙ†Ø´Ø¦ Ø´Ø±ÙŠØ· ØªÙ‚Ø¯Ù… Ù†ØµÙŠ Ø¬Ù…ÙŠÙ„."""
    percentage = max(0, min(100, percentage))
    filled_length = int(percentage / 10)
    bar = 'â–ˆ' * filled_length + '-' * (10 - filled_length)
    return f"[{bar}] {percentage:.1f}%"

def calculate_price(pages_count):
    """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©."""
    price_per_page = PRICE_PER_PAGE_LT50 if pages_count < 50 else PRICE_PER_PAGE_GTE50
    base_price = pages_count * price_per_page
    price_without_cover = int(math.ceil(base_price / 250.0) * 250)
    price_with_cover = int(math.ceil((base_price + COVER_BINDING_COST) / 250.0) * 250)
    return price_without_cover, price_with_cover

async def count_pages_for_document(file_path):
    """
    Ø¹Ø¯ Ø§Ù„ØµÙØ­Ø§Øª ÙÙŠ Ù…Ù„Ù Ù…Ø¹ÙŠÙ† (PDF, DOCX, PPTX).
    ÙŠØ±Ø¬Ø¹ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø£Ùˆ 0 Ø¥Ø°Ø§ Ù„Ù… ÙŠÙ…ÙƒÙ† ØªØ­Ø¯ÙŠØ¯Ù‡.
    """
    if not os.path.exists(file_path):
        logger.error(f"Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØµÙØ­Ø§Øª: {file_path}")
        return 0

    ext = os.path.splitext(file_path)[1].lower()
    try:
        if ext == '.pdf':
            with fitz.open(file_path) as doc:
                return len(doc)
        elif ext == '.docx':
            doc = docx.Document(file_path)
            return doc.core_properties.pages if hasattr(doc.core_properties, 'pages') and doc.core_properties.pages else 1
        elif ext == '.pptx':
            presentation = pptx.Presentation(file_path)
            return len(presentation.slides)
        else:
            logger.warning(f"Unsupported file extension for page count: {ext}")
            return 0
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„ØµÙØ­Ø§Øª Ù„Ù„Ù…Ù„Ù '{os.path.basename(file_path)}': {e}")
        return 0

def get_available_printers():
    """ÙŠØ¹ÙŠØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù…."""
    if not WINDOWS_PRINTING_ENABLED:
        return ["Simulated_Printer"]
    try:
        printers = [p[2] for p in win32print.EnumPrinters(2)]
        return printers
    except Exception as e:
        logger.error(f"Failed to list printers: {e}")
        return []

def get_ready_printer():
    """ÙŠÙØ­Øµ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙˆÙŠØ¹ÙŠØ¯ Ø§Ø³Ù… Ø£ÙˆÙ„ Ø·Ø§Ø¨Ø¹Ø© Ø¬Ø§Ù‡Ø²Ø©."""
    if not WINDOWS_PRINTING_ENABLED:
        logger.warning("Printing is simulated. Cannot get real printer status.")
        return "Simulated_Printer" # Ø§Ø³Ù… Ø·Ø§Ø¨Ø¹Ø© Ù…Ø­Ø§ÙƒØ§Ø©

    available_printers = get_available_printers()
    printers_to_check = [p for p in [PRINTER_NAME_1, PRINTER_NAME_2] if p and p in available_printers]

    for printer_name in printers_to_check:
        try:
            handle = win32print.OpenPrinter(printer_name)
            status = win32print.GetPrinter(handle, 2)['Status']
            win32print.ClosePrinter(handle)
            if status == 0: # 0 ÙŠØ¹Ù†ÙŠ Ø¬Ø§Ù‡Ø²Ø©
                logger.info(f"Printer '{printer_name}' is ready.")
                return printer_name
        except Exception as e:
            logger.error(f"Could not check status for printer '{printer_name}': {e}")
    return None # Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ø§Ø¨Ø¹Ø© Ø¬Ø§Ù‡Ø²Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©

async def send_to_printer(file_path, printer_name):
    """ÙŠØ±Ø³Ù„ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©."""
    if not WINDOWS_PRINTING_ENABLED:
        logger.info(f"SIMULATING: Printing file '{os.path.basename(file_path)}' to '{printer_name}'.")
        await asyncio.sleep(15) # Ù…Ø­Ø§ÙƒØ§Ø© ÙˆÙ‚Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©
        return True, "ØªÙ…Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­ (Ù…Ø­Ø§ÙƒØ§Ø©)."
    if not os.path.exists(file_path):
        error_message = f"Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯: {file_path}"
        logger.error(error_message)
        return False, error_message

    try:
        absolute_file_path = os.path.abspath(file_path)
        win32api.ShellExecute(0, "print", f'"{absolute_file_path}"', f'"{printer_name}"', ".", 0)
        logger.info(f"Successfully sent '{os.path.basename(file_path)}' to printer '{printer_name}'.")
        await asyncio.sleep(10) # Ø§Ù†ØªØ¸Ø§Ø± Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø±
        return True, f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø·Ø§Ø¨Ø¹Ø© '{printer_name}'."
    except Exception as e:
        error_message = f"Failed to print file '{os.path.basename(file_path)}'. Error: {e}"
        logger.error(error_message)
        return False, str(e)

async def send_group_notification(message, **kwargs):
    """ÙŠØ±Ø³Ù„ Ø¥Ø´Ø¹Ø§Ø±Ù‹Ø§ Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù…Ø§Ù„Ùƒ."""
    if PRINTING_GROUP_ID:
        try:
            await client.send_message(PRINTING_GROUP_ID, message, **kwargs)
        except Exception as e:
            logger.error(f"Failed to send notification to group {PRINTING_GROUP_ID}: {e}")
    else:
        logger.warning("PRINTING_GROUP_ID is not set. Skipping group notification.")

async def download_file(message, download_path_base, status_message):
    """
    ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Ù…Ù† Ø±Ø³Ø§Ù„Ø© Telegram Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯. Ù…Ø¹ Ø¹Ø±Ø¶ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù….
    ÙŠØ±Ø¬Ø¹ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­Ù…Ù„ Ø£Ùˆ None ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„.
    """
    if not message or not message.document:
        await status_message.edit("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªÙ†Ø¯ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
        return None

    file_name = None
    if message.document.attributes:
        for attr in message.document.attributes:
            if isinstance(attr, DocumentAttributeFilename):
                file_name = attr.file_name
                break
    if not file_name:
        file_name = f"unknown_file_{random.randint(1000, 9999)}" # Ø§Ø³Ù… Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯

    full_path = os.path.join(download_path_base, file_name)

    try:
        progress_bar_length = 20
        bytes_downloaded = 0
        total_bytes = message.document.size

        def progress_callback(current, total):
            nonlocal bytes_downloaded
            bytes_downloaded = current
            percent = (current / total) * 100 if total > 0 else 0
            filled_length = int(progress_bar_length * current // total) if total > 0 else 0
            bar = 'â–ˆ' * filled_length + '-' * (progress_bar_length - filled_length)
            asyncio.create_task(status_message.edit(f"â³ Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„: [{bar}] {percent:.1f}%"))

        await message.download_media(file=full_path, progress_callback=progress_callback)
        await status_message.edit("âœ… Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„.")
        return full_path

    except FloodWaitError as e:
        logger.error(f"Flood wait error during download: {e}")
        await status_message.edit(f"âŒ ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ø³Ø¨Ø¨ Ø§Ù†ØªØ¸Ø§Ø±: {e.seconds} Ø«Ø§Ù†ÙŠØ©.")
        return None
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: {e}")
        await status_message.edit(f"âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: {e}")
        return None

async def save_settings():
    """Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø¨ÙˆØª ÙÙŠ Ù…Ù„Ù config.ini."""
    global PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST, custom_auto_reply_message, ignored_users, ADMIN_IDS

    config = configparser.ConfigParser()

    config['TELEGRAM'] = {
        'api_id': str(API_ID) if API_ID is not None else '',
        'api_hash': API_HASH if API_HASH is not None else '',
        'session_string': SESSION_STRING if SESSION_STRING is not None else '',
        'printing_group_id': str(PRINTING_GROUP_ID) if PRINTING_GROUP_ID is not None else ''
    }

    config['PRINTER'] = {
        'printer_name_1': PRINTER_NAME_1 if PRINTER_NAME_1 is not None else '',
        'printer_name_2': PRINTER_NAME_2 if PRINTER_NAME_2 is not None else ''
    }

    config['PRICES'] = {
        'price_per_page_lt50': str(PRICE_PER_PAGE_LT50),
        'price_per_page_gte50': str(PRICE_PER_PAGE_GTE50),
        'cover_binding_cost': str(COVER_BINDING_COST)
    }

    config['BOT_CONFIG'] = {
        'custom_auto_reply_message': custom_auto_reply_message,
        'ignored_users': ",".join(map(str, ignored_users)) # Ø­ÙØ¸Ù‡Ø§ ÙƒØ³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© Ù…ÙØµÙˆÙ„Ø© Ø¨ÙÙˆØ§ØµÙ„
    }
    
    config['ADMINS'] = {
        'admin_ids': ",".join(map(str, ADMIN_IDS))
    }

    try:
        with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
            config.write(f)
        logger.info("ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.")
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: {e}")

def load_settings():
    """ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ù† Ù…Ù„Ù config.ini."""
    global API_ID, API_HASH, SESSION_STRING, PRINTING_GROUP_ID, PRINTER_NAME_1, PRINTER_NAME_2
    global PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST, custom_auto_reply_message, ignored_users, ADMIN_IDS

    config = configparser.ConfigParser()

    if not os.path.exists(SETTINGS_FILE):
        logger.warning(f"Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª '{SETTINGS_FILE}' ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡ Ø¨Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©.")
        create_default_settings() # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
        save_settings() # Ø«Ù… Ø­ÙØ¸Ù‡Ø§
        return True # ØªØ´ÙŠØ± Ø¥Ù„Ù‰ Ø£Ù†Ù‡ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­ (Ù…Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©)

    try:
        config.read(SETTINGS_FILE, encoding='utf-8')

        api_id_str = config.get('TELEGRAM', 'api_id', fallback=None)
        API_ID = int(api_id_str) if api_id_str and api_id_str.strip().lstrip('-').isdigit() else None
        API_HASH = config.get('TELEGRAM', 'api_hash', fallback=None)
        SESSION_STRING = config.get('TELEGRAM', 'session_string', fallback=None)
        printing_group_id_str = config.get('TELEGRAM', 'printing_group_id', fallback=None)
        PRINTING_GROUP_ID = int(printing_group_id_str) if printing_group_id_str and printing_group_id_str.strip().lstrip('-').isdigit() else None

        PRINTER_NAME_1 = config.get('PRINTER', 'printer_name_1', fallback=None)
        PRINTER_NAME_2 = config.get('PRINTER', 'printer_name_2', fallback=None)

        price_lt50_str = config.get('PRICES', 'price_per_page_lt50', fallback='50')
        PRICE_PER_PAGE_LT50 = int(price_lt50_str) if price_lt50_str and price_lt50_str.strip().lstrip('-').isdigit() else 50
        price_gte50_str = config.get('PRICES', 'price_per_page_gte50', fallback='40')
        PRICE_PER_PAGE_GTE50 = int(price_gte50_str) if price_gte50_str and price_gte50_str.strip().lstrip('-').isdigit() else 40
        cover_cost_str = config.get('PRICES', 'cover_binding_cost', fallback='500')
        COVER_BINDING_COST = int(cover_cost_str) if cover_cost_str and cover_cost_str.strip().lstrip('-').isdigit() else 500

        custom_auto_reply_message = config.get('BOT_CONFIG', 'custom_auto_reply_message', fallback="")
        ignored_users_str = config.get('BOT_CONFIG', 'ignored_users', fallback='')
        ignored_users = set(int(uid) for uid in ignored_users_str.split(',') if uid.strip() and uid.strip().lstrip('-').isdigit())

        admin_ids_str = config.get('ADMINS', 'admin_ids', fallback='')
        ADMIN_IDS = set(int(uid) for uid in admin_ids_str.split(',') if uid.strip() and uid.strip().lstrip('-').isdigit())

        logger.info("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.")
        return True
    except (configparser.NoSectionError, configparser.NoOptionError, ValueError) as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª '{SETTINGS_FILE}': {e}. Ù‚Ø¯ ØªÙƒÙˆÙ† Ø¨Ø¹Ø¶ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©.")
        logger.warning("Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ø¨Ø¹Ø¶ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.")
        return False
    except Exception as e:
        logger.critical(f"Ø®Ø·Ø£ ÙØ§Ø¯Ø­ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: {e}", exc_info=True)
        return False

def create_default_settings():
    """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹."""
    global API_ID, API_HASH, SESSION_STRING, PRINTING_GROUP_ID, PRINTER_NAME_1, PRINTER_NAME_2
    global PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST, custom_auto_reply_message, ignored_users, ADMIN_IDS, owner_id

    API_ID = 16504919
    API_HASH = 'e9ddbc4aa70093979dcc2d20153fba08'
    SESSION_STRING = '1ApWapzMBuxOg0QsYt7P69PuZ8uTaNzZT0EKTRg0ZTMgW2EJi_1NfklhoWENh46h-YkMaib4UqLxb3nREIXX8UX9-9lXxZwMJTqcZqYJJDd6jhpddO4R7Nh65Vt-cE7PP1A3pDv2fYaUCL4vm2CfxyL5C-8-XgrOcclv4bU4QrDFwTbGA6hShF1rJPh1zzDXSblbfcDgGHybECg7rBRfA7YZwBVb1G5vh1Kaya3PQ8f18rdQQaHfslGQAhNDDjg6R4DEAlXVRxNmfrIiUN_K4N_M9m_nUt9N2uGoGtrqyM_qAe9Qn4Sbugf7dKNJDle-TGPBFb0euEiFVKnOelN9oa4R0K245FpQ='
    PRINTING_GROUP_ID = -1002818366552
    PRINTER_NAME_1 = "HP PageWide MFP P57750 PCL 6"
    PRINTER_NAME_2 = "HP LaserJet MFP M130fw"
    PRICE_PER_PAGE_LT50 = 50
    PRICE_PER_PAGE_GTE50 = 40
    COVER_BINDING_COST = 500
    custom_auto_reply_message = ""
    ignored_users = set()
    ADMIN_IDS = set() # Ø³ØªØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø§Ù„Ùƒ Ù„Ø§Ø­Ù‚Ù‹Ø§ Ø¨Ø¹Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„

    logger.info("ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ.")

def get_user_full_name(user):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø¸Ù…."""
    if user.first_name and user.last_name:
        return f"{user.first_name} {user.last_name}"
    elif user.first_name:
        return user.first_name
    elif user.username:
        return f"@{user.username}"
    else:
        return f"User_{user.id}"

def get_command_inline_keyboard(command_prefix="."):
    """Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ø¨Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ø´Ø±Ø­."""
    keyboard = []
    commands = {
        "ğŸ“Š Stats": f"{command_prefix}ØªÙØ¹ÙŠÙ„",
        "ğŸ–¨ï¸ Print": f"{command_prefix}Ø·Ø¨Ø§Ø¹Ø©",
        "ğŸ’° Price": f"{command_prefix}Ø³Ø¹Ø±",
        "ğŸ’¡ Test Print": f"{command_prefix}ØªÙŠØ³Øª",
        "ğŸ˜´ Sleep": f"{command_prefix}Ù†Ø§ÙŠÙ…",
        "â˜€ï¸ Wake Up": f"{command_prefix}ÙƒØ§Ø¹Ø¯",
        "ğŸš« Ignore": f"{command_prefix}Ø³Ù…Ø§Ø­",
        "âœ… Unignore": f"{command_prefix}Ø§Ù„ØºØ§Ø¡",
        "ğŸ“¢ Broadcast": f"{command_prefix}Ø§Ø°Ø§Ø¹Ø©",
        "âš™ï¸ Settings": f"{command_prefix}Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª",
        "ğŸ“š Files": f"{command_prefix}Ù…Ù„Ù",
    }

    sorted_commands = sorted(commands.items(), key=lambda item: item[0])

    row = []
    for text, command in sorted_commands:
        row.append(KeyboardButtonCallback(text=text, callback_data=command))
        if len(row) == 2:
            keyboard.append(row)
            row = []
    if row: # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙ Ø§Ù„Ø£Ø®ÙŠØ± Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± ÙˆØ§Ø­Ø¯
        keyboard.append(row)

    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# --- 7. Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠØ© ---
async def is_admin(event):
    if not event.is_group:
        return False
    participants = await event.client.get_participants(event.chat_id, filter=ChannelParticipantsAdmins)
    return any(user.id == event.sender_id for user in participants)
async def admin_handler(event):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªÙŠ ØªØ¨Ø¯Ø£ Ø¨Ù€ '.' Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†."""
    global is_sleeping, custom_auto_reply_message, PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST, ignored_users, ADMIN_IDS

    command_full = event.pattern_match.group(1).strip()
    parts = command_full.split(maxsplit=1)
    command = parts[0].lower()
    args = parts[1] if len(parts) > 1 else None

    # --- Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ---
    if command == "Ù…" or command == "Ù…Ø³Ø§Ø¹Ø¯Ø©":
        help_message = "**Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆØ§Ù…Ø± Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰!**\n\n"
        help_message += "**ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ­Ø§Ù„Ø© Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰:**\n"
        help_message += "  - `.ØªÙØ¹ÙŠÙ„`: Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠØ©.\n"
        help_message += "  - `.ÙØ­Øµ`: ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª.\n"
        help_message += "  - `.Ù†Ø§ÙŠÙ…`: ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… (Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ).\n"
        help_message += "  - `.ÙƒØ§Ø¹Ø¯`: Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ….\n"
        help_message += "  - `.ØªÙ†Ø§ÙŠÙ… [Ù†Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø©]`: ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… Ù…Ø¹ Ø±Ø³Ø§Ù„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù…Ø®ØµØµØ©.\n"
        help_message += "  - `.Ø³Ø¬Ù„`: Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ (Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†. Ø§Ù„Ø£Ø³Ø¹Ø§Ø±).\n\n"

        help_message += "**ğŸ–¨ï¸ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ÙˆØ§Ù„ØªØ³Ø¹ÙŠØ±:**\n"
        help_message += "  - `.Ø³Ø¹Ø±` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ù…Ù„Ù): Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù…Ù„Ù.\n"
        help_message += "  - `.Ø·Ø¨Ø§Ø¹Ø©` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ù…Ù„Ù): Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©.\n"
        help_message += "  - `.ØªÙŠØ³Øª`: Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ø®ØªØ¨Ø§Ø± Ù„Ù„Ø·Ø§Ø¨Ø¹Ø©.\n"
        help_message += "  - `.Øª1 [Ø±Ù‚Ù…]`: ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (Ø£Ù‚Ù„ Ù…Ù† 50).\n"
        help_message += "  - `.Øª2 [Ø±Ù‚Ù…]`: ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (50 ØµÙØ­Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±).\n"
        help_message += "  - `.Øª3 [Ø±Ù‚Ù…]`: ØªØ¹Ø¯ÙŠÙ„ ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯.\n\n"

        help_message += "**ğŸ‘¤ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†:**\n"
        help_message += "  - `.Ø³Ù…Ø§Ø­` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©): Ù…Ù†Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©.\n"
        help_message += "  - `.Ø§Ù„ØºØ§Ø¡` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©): Ø¥Ù„ØºØ§Ø¡ Ù…Ù†Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©.\n"
        help_message += "  - `.Ø§Ù„ØºØ§Ø¡Ùƒ`: Ø¥Ù„ØºØ§Ø¡ Ù…Ù†Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ†.\n"
        help_message += "  - `.Ø§Ù„ØºØ§Ø¡_Ø§ÙŠØ¯ÙŠ [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]`: Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ† Ø¹Ø¨Ø± Ù…Ø¹Ø±ÙÙ‡.\n"
        help_message += "  - `.Ùƒ` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©): Ø¥Ø®Ø·Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø£Ù† Ø·Ù„Ø¨Ù‡ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªÙ„Ø§Ù….\n"
        help_message += "  - `.Ø§Ø°Ø§Ø¹Ø©` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©): Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¹Ø±ÙˆÙÙŠÙ†.\n"
        help_message += "  - `.Ø§Ø¶Ù_Ø§Ø¯Ù…Ù† [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]`: Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø¤ÙˆÙ„ Ø¬Ø¯ÙŠØ¯.\n"
        help_message += "  - `.Ø­Ø°Ù_Ø§Ø¯Ù…Ù† [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]`: Ø¥Ø²Ø§Ù„Ø© Ù…Ø³Ø¤ÙˆÙ„.\n\n"

        help_message += "**ğŸ› ï¸ Ø£ÙˆØ§Ù…Ø± Ø£Ø®Ø±Ù‰:**\n"
        help_message += "  - `.Ø­Ù„Ùˆ` (Ù…Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø©): Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.\n"
        help_message += "  - `.Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª`: Ø¹Ø±Ø¶ Ø®ÙŠØ§Ø±Ø§Øª ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±.\n"
        help_message += "  - `.Ù…Ù„Ù`: Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø®ØµØµØ© ÙˆØªØ´ØºÙŠÙ„Ù‡Ø§.\n"

        await event.edit(help_message)
        return

    # --- Ø£ÙˆØ§Ù…Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„ØªØ­ÙƒÙ… ---
    elif command == "ØªÙØ¹ÙŠÙ„":
        uptime_delta = datetime.now() - bot_start_time
        uptime_str = str(timedelta(seconds=int(uptime_delta.total_seconds()))).split('.')[0]
        stats_msg = (
            f"**âœ… Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ**\n"
            f"**â³ Ù…Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„:** `{uptime_str}`\n"
            f"**ğŸ’¤ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ…:** `{'Ù…ÙÙØ¹Ù‘Ù„' if is_sleeping else 'Ù…ÙØ¹Ø·Ù‘Ù„'}`\n"
            f"**ğŸ‘¥ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù…Ø¹Ø±ÙˆÙÙˆÙ†:** `{len(all_known_users)}` | **Ø§Ù„Ù…ØªØ¬Ø§Ù‡Ù„ÙˆÙ†:** `{len(ignored_users)}`\n"
            f"**ğŸ‘‘ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙˆÙ†:** `{len(ADMIN_IDS)}`"
        )
        await event.edit(stats_msg)

    elif command == "ÙØ­Øµ":
        await event.edit("ğŸ©º **Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø­Ø§Ù„Ø© Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰...**")
        printers_list = get_available_printers()
        p1_status = "âœ…" if PRINTER_NAME_1 and PRINTER_NAME_1 in printers_list else "âŒ"
        p2_status = "âœ…" if PRINTER_NAME_2 and PRINTER_NAME_2 in printers_list else "âŒ"
        status_report = (
            f"**ğŸ“Š ØªÙ‚Ø±ÙŠØ± ÙØ­Øµ:**\n"
            f"- **Ø§ØªØµØ§Ù„ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰:** âœ…\n"
            f"- **Ù†Ø¸Ø§Ù… Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© (ÙˆÙŠÙ†Ø¯ÙˆØ²):** `{'âœ…' if WINDOWS_PRINTING_ENABLED else 'â›”'}`\n"
            f"- **Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ (`{PRINTER_NAME_1 or 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©'}`):** {p1_status}\n"
            f"- **Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© (`{PRINTER_NAME_2 or 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©'}`):** {p2_status}"
        )
        await event.edit(status_report)

    elif command == "Ù†Ø§ÙŠÙ…":
        is_sleeping = True
        await event.edit("ğŸŒ™ **ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ…. Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¨Ø±Ø³Ø§Ù„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ©.**")

    elif command == "ÙƒØ§Ø¹Ø¯":
        is_sleeping = False
        await event.edit("â˜€ï¸ **ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ…. Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ Ø¬Ø§Ù‡Ø² Ù„ØªÙ„Ù‚ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª.**")

    elif command == "ØªÙ†Ø§ÙŠÙ…":
        if not args:
            await event.edit("âš ï¸ **Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø·Ø¦.**\nÙ„ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… Ø¨Ø±Ø¯ Ù…Ø®ØµØµ. Ø§Ø³ØªØ®Ø¯Ù…: `.ØªÙ†Ø§ÙŠÙ… Ù†Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©`")
            return
        is_sleeping = True
        custom_auto_reply_message = args
        await save_settings()
        await event.edit(f"ğŸŒ™ **ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… Ø¨Ø±Ø¯ Ù…Ø®ØµØµ:**\n`{args}`")

    # --- Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ÙˆØ§Ù„ØªØ³Ø¹ÙŠØ± ---
    elif command == "Ø³Ø¹Ø±" and event.is_reply:
        reply_msg = await event.get_reply_message()
        if reply_msg and reply_msg.document:
            await event.edit("â³ **Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ©...**")
            status_message = await event.get_reply_to_message() # Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£ØµÙ„ÙŠØ©
            path = await download_file(reply_msg, DOWNLOAD_PATH, status_message)
            if path:
                pages = await count_pages_for_document(path)
                if pages > 0:
                    price_no_cover, price_with_cover = await calculate_price(pages)
                    await status_message.edit(
                        f"ğŸ“„ **Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ {pages} ØµÙØ­Ø©.**\n"
                        f"ğŸ’° **Ø§Ù„ØªÙƒÙ„ÙØ© (Ø¨Ø¯ÙˆÙ† ØªØ¬Ù„ÙŠØ¯):** `{price_no_cover}`\n"
                        f"ğŸ’° **Ø§Ù„ØªÙƒÙ„ÙØ© (Ù…Ø¹ ØªØ¬Ù„ÙŠØ¯):** `{price_with_cover}`"
                    )
                else:
                    await status_message.edit("âŒ **Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ù„Ù„Ù…Ù„Ù.**")
                try: os.remove(path)
                except OSError as e: logger.warning(f"ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª: {e}")
            else:
                pass
        else:
            await event.edit("âŒ **ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ù„Ù Ù„Ø­Ø³Ø§Ø¨ Ø³Ø¹Ø±Ù‡.**")

    elif command == "Ø·Ø¨Ø§Ø¹Ø©" and event.is_reply:
        reply_msg = await event.get_reply_message()
        if reply_msg and reply_msg.document:
            await event.edit("â³ **Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡ Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©...**")
            status_message = await event.get_reply_to_message() # Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£ØµÙ„ÙŠØ©
            path = await download_file(reply_msg, DOWNLOAD_PATH, status_message)
            if path:
                printer_to_use = get_ready_printer()
                if printer_to_use:
                    success, error_msg = await asyncio.to_thread(send_to_printer, path, printer_to_use)
                    if success:
                        await status_message.edit(f"âœ… **ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù '{os.path.basename(path)}' Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­!**")
                        await send_group_notification(f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù '{os.path.basename(path)}' Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© '{printer_to_use}' Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù….")
                    else:
                        await status_message.edit(f"âŒ **ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©:**\n`{error_msg}`\n**Ù†ØµÙŠØ­Ø©:** ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© ØªØ¹Ù…Ù„ ÙˆØ£Ù† ØªØ¹Ø±ÙŠÙØ§ØªÙ‡Ø§ Ù…Ø­Ø¯Ø«Ø©.")
                else:
                    await status_message.edit("âŒ **Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ø§Ø¨Ø¹Ø© Ø¬Ø§Ù‡Ø²Ø© Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§.**")
                try: os.remove(path)
                except OSError as e: logger.warning(f"ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª: {e}")
            else:
                pass
        else:
            await event.edit("âŒ **ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ù„Ù Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡ Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©.**")

    elif command == "ØªÙŠØ³Øª":
        await event.edit("â³ **Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ø®ØªØ¨Ø§Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©...**")
        test_file_path = os.path.join(DOWNLOAD_PATH, "test_print_file.txt")
        try:
            with open(test_file_path, "w", encoding='utf-8') as f:
                f.write("--- ØµÙØ­Ø© Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù† Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ---\n\n")
                f.write(f"ÙˆÙ‚Øª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

            printer_to_use = get_ready_printer()
            if printer_to_use:
                success, error_msg = await asyncio.to_thread(send_to_printer, test_file_path, printer_to_use)
                if success:
                    await event.edit(f"âœ… **ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ `{printer_to_use}`!**")
                else:
                    await event.edit(f"âŒ **ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:**\n`{error_msg}`")
            else:
                await event.edit("âŒ **Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ø§Ø¨Ø¹Ø© Ø¬Ø§Ù‡Ø²Ø© Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§ Ù„Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.**")
        finally:
            if os.path.exists(test_file_path):
                try: os.remove(test_file_path)
                except OSError as e: logger.warning(f"ÙØ´Ù„ Ø­Ø°Ù Ù…Ù„Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±: {e}")

    elif command in ["Øª1", "Øª2", "Øª3"]:
        if not args or not args.strip().lstrip('-').isdigit():
            await event.edit("âš ï¸ **Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø·Ø¦.**\n- Ø§Ø³ØªØ®Ø¯Ù… `.Øª1 [Ø§Ù„Ù‚ÙŠÙ…Ø©]` Ù„ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© Ù„Ù€ Ø£Ù‚Ù„ Ù…Ù† 50.\n- Ø§Ø³ØªØ®Ø¯Ù… `.Øª2 [Ø§Ù„Ù‚ÙŠÙ…Ø©]` Ù„ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© Ù„Ù€ 50 Ø£Ùˆ Ø£ÙƒØ«Ø±.\n- Ø§Ø³ØªØ®Ø¯Ù… `.Øª3 [Ø±Ù‚Ù…]` Ù„ØªØ­Ø¯ÙŠØ« ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯.")
            return

        value = int(args)
        if command == "Øª1":
            PRICE_PER_PAGE_LT50 = value
            await event.edit(f"âœ… **ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (Ø£Ù‚Ù„ Ù…Ù† 50 ØµÙØ­Ø©) Ø¥Ù„Ù‰:** `{PRICE_PER_PAGE_LT50}`")
        elif command == "Øª2":
            PRICE_PER_PAGE_GTE50 = value
            await event.edit(f"âœ… **ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (50 ØµÙØ­Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±) Ø¥Ù„Ù‰:** `{PRICE_PER_PAGE_GTE50}`")
        elif command == "Øª3":
            COVER_BINDING_COST = value
            await event.edit(f"âœ… **ØªÙ… ØªØ­Ø¯ÙŠØ« ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯ Ø¥Ù„Ù‰:** `{COVER_BINDING_COST}`")

        await save_settings()

    # --- Ø£ÙˆØ§Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ---
    elif command == "Ø³Ù…Ø§Ø­" and event.is_reply:
        try:
            user_to_ignore_id = (await event.get_reply_message()).sender_id
            if user_to_ignore_id == owner_id:
                await event.edit("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø§Ù„Ùƒ.")
                return
            if user_to_ignore_id in ADMIN_IDS:
                await event.edit("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ø§Ù‡Ù„ Ù…Ø³Ø¤ÙˆÙ„ Ø¢Ø®Ø±.")
                return

            ignored_users.add(user_to_ignore_id)
            await save_settings()
            await event.edit(f"ğŸš« **ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_to_ignore_id}` Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ† (Ù„Ù† ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù„ÙŠÙ‡).**")
        except Exception as e:
            await event.edit(f"âŒ **Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…ÙØ±ÙØ¯ Ø¹Ù„ÙŠÙ‡Ø§:** {e}")

    elif command == "Ø§Ù„ØºØ§Ø¡" and event.is_reply:
        try:
            user_to_unignore_id = (await event.get_reply_message()).sender_id
            if user_to_unignore_id in ignored_users:
                ignored_users.discard(user_to_unignore_id)
                await save_settings()
                await event.edit(f"âœ… **ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_to_unignore_id}` Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ†.**")
            else:
                await event.edit(f"â“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_to_unignore_id}` ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ†.")
        except Exception as e:
            await event.edit(f"âŒ **Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…ÙØ±ÙØ¯ Ø¹Ù„ÙŠÙ‡Ø§:** {e}")

    elif command == "Ø§Ù„ØºØ§Ø¡Ùƒ":
        if not ignored_users:
            await event.edit("â„¹ï¸ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ† ÙØ§Ø±ØºØ© Ø­Ø§Ù„ÙŠÙ‹Ø§.")
            return
        ignored_list_str = ", ".join(map(str, ignored_users))
        ignored_users.clear()
        await save_settings()
        await event.edit(f"âœ… **ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ†.**\n**Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ø°ÙŠÙ† ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡Ù…:** `{ignored_list_str}`")

    elif command == "Ø§Ù„ØºØ§Ø¡_Ø§ÙŠØ¯ÙŠ":
        if not args or not args.strip().lstrip('-').isdigit():
            await event.edit("âš ï¸ **Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø·Ø¦.**\nØ§Ø³ØªØ®Ø¯Ù… `.Ø§Ù„ØºØ§Ø¡_Ø§ÙŠØ¯ÙŠ [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]` Ù„Ø¥Ø²Ø§Ù„Ø© Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ† Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ¬Ø§Ù‡Ù„.")
            return
        user_id_to_remove = int(args)
        if user_id_to_remove in ignored_users:
            ignored_users.discard(user_id_to_remove)
            await save_settings()
            await event.edit(f"âœ… **ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø°Ùˆ Ø§Ù„Ù…Ø¹Ø±Ù `{user_id_to_remove}` Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ†.**")
        else:
            await event.edit(f"â“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø°Ùˆ Ø§Ù„Ù…Ø¹Ø±Ù `{user_id_to_remove}` ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙŠÙ†.")

    elif command == "Ùƒ" and event.is_reply:
        try:
            user_to_notify_id = (await event.get_reply_message()).sender_id
            if user_to_notify_id == owner_id or user_to_notify_id in ADMIN_IDS:
                await event.edit("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¬Ø§Ù‡Ø²ÙŠØ© Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø¢Ø®Ø± Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©.")
                return
            await client.send_message(user_to_notify_id, "âœ… **Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø·Ù„Ø¨Ùƒ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªÙ„Ø§Ù… Ù…Ù† Ø§Ù„Ù…ÙƒØªØ¨Ø©.**")
            await event.edit("ğŸ‘ **ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù….**")
        except PeerIdInvalidError:
            await event.edit("âŒ **Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.**")
        except UserIsBlockedError:
            await event.edit("âŒ **Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‚Ø§Ù… Ø¨Ø­Ø¸Ø± Ø§Ù„Ø¨ÙˆØª.**")
        except Exception as e:
            await event.edit(f"âŒ **Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:** {e}")

    elif command == "Ø§Ø°Ø§Ø¹Ø©" and event.is_reply:
        msg_to_broadcast = await event.get_reply_message()
        if not msg_to_broadcast:
            await event.edit("âŒ **ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡Ø§.**")
            return

        await event.edit(f"ğŸ“£ **Ø¬Ø§Ø±ÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù€ {len(all_known_users)} Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹Ø±ÙˆÙ...**")
        sent_count = 0
        failed_count = 0
        users_to_ignore_after_broadcast = set()

        users_to_process = list(all_known_users) # Ù†Ø£Ø®Ø° Ù†Ø³Ø®Ø© Ù„Ù†ØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø±ÙˆØ±
        
        for user_id in users_to_process:
            if user_id == owner_id or user_id in ADMIN_IDS: continue # ØªØ¬Ù†Ø¨ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†
            try:
                await client.send_message(user_id, msg_to_broadcast)
                sent_count += 1
                await asyncio.sleep(0.1) # Ù„ØªØ¬Ù†Ø¨ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ÙˆØ¯
            except PeerIdInvalidError:
                failed_count += 1
                users_to_ignore_after_broadcast.add(user_id)
            except UserIsBlockedError:
                failed_count += 1
                users_to_ignore_after_broadcast.add(user_id)
            except FloodWaitError as e:
                logger.warning(f"Flood wait error during broadcast: {e.seconds}s. Waiting...")
                await asyncio.sleep(e.seconds + 2)
                failed_count += 1
                users_to_ignore_after_broadcast.add(user_id)
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")
                failed_count += 1
                users_to_ignore_after_broadcast.add(user_id)

        ignored_users.update(users_to_ignore_after_broadcast)
        if users_to_ignore_after_broadcast:
            await save_settings()

        await event.edit(f"âœ… **Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©!**\n"
                         f"âœ”ï¸ ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰: `{sent_count}` Ù…Ø³ØªØ®Ø¯Ù….\n"
                         f"âŒ ÙØ´Ù„Øª Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù€: `{failed_count}` Ù…Ø³ØªØ®Ø¯Ù… (Ù‚Ø¯ ÙŠØªÙ… ØªØ¬Ø§Ù‡Ù„Ù‡Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§).")

    # --- Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ---
    elif command == "Ø³Ø¬Ù„":
        stats_msg = (
            f"**ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:**\n"
            f"- **Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¹Ø±ÙˆÙÙŠÙ†:** `{len(all_known_users)}`\n"
            f"- **Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù…ØªØ¬Ø§Ù‡ÙÙ„ÙˆÙ†:** `{len(ignored_users)}`\n"
            f"- **Ø±Ø³ÙˆÙ… Ø§Ù„ØµÙØ­Ø© <50:** `{PRICE_PER_PAGE_LT50}`\n"
            f"- **Ø±Ø³ÙˆÙ… Ø§Ù„ØµÙØ­Ø© >=50:** `{PRICE_PER_PAGE_GTE50}`\n"
            f"- **ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯:** `{COVER_BINDING_COST}`\n"
            f"- **Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙˆÙ† Ø§Ù„Ù…Ø¶Ø§ÙÙˆÙ†:** `{len(ADMIN_IDS - {owner_id})}`"
        )
        await event.edit(stats_msg)

    # --- Ø£ÙˆØ§Ù…Ø± ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± (Ù…Ø¹ Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­) ---
    elif command == "Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª":
        await send_settings_menu(event) # Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø¯Ø§Ù„Ø© Ø¥Ø±Ø³Ø§Ù„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª

    # --- Ø£ÙˆØ§Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ---
    elif command == "Ø§Ø¶Ù_Ø§Ø¯Ù…Ù†" and args:
        if not args.strip().lstrip('-').isdigit():
            await event.edit("âš ï¸ **Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø·Ø¦.**\nØ§Ø³ØªØ®Ø¯Ù… `.Ø§Ø¶Ù_Ø§Ø¯Ù…Ù† [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]` Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø¤ÙˆÙ„ Ø¬Ø¯ÙŠØ¯.")
            return
        new_admin_id = int(args)
        if new_admin_id == owner_id:
            await event.edit("âŒ Ø§Ù„Ù…Ø§Ù„Ùƒ Ù‡Ùˆ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ø¨Ø§Ù„ÙØ¹Ù„.")
            return
        if new_admin_id in ADMIN_IDS:
            await event.edit(f"âœ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{new_admin_id}` Ù‡Ùˆ Ø¨Ø§Ù„ÙØ¹Ù„ Ù…Ø³Ø¤ÙˆÙ„.")
            return
        ADMIN_IDS.add(new_admin_id)
        await save_settings() # Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
        await event.edit(f"âœ… **ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{new_admin_id}` ÙƒÙ…Ø³Ø¤ÙˆÙ„.**")

    elif command == "Ø­Ø°Ù_Ø§Ø¯Ù…Ù†" and args:
        if not args.strip().lstrip('-').isdigit():
            await event.edit("âš ï¸ **Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø·Ø¦.**\nØ§Ø³ØªØ®Ø¯Ù… `.Ø­Ø°Ù_Ø§Ø¯Ù…Ù† [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]` Ù„Ø¥Ø²Ø§Ù„Ø© Ù…Ø³Ø¤ÙˆÙ„.")
            return
        admin_id_to_remove = int(args)
        if admin_id_to_remove == owner_id:
            await event.edit("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ù…Ø§Ù„Ùƒ.")
            return
        if admin_id_to_remove in ADMIN_IDS:
            ADMIN_IDS.discard(admin_id_to_remove)
            await save_settings() # Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
            await event.edit(f"âœ… **ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ `{admin_id_to_remove}`.**")
        else:
            await event.edit(f"â“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø°Ùˆ Ø§Ù„Ù…Ø¹Ø±Ù `{admin_id_to_remove}` Ù„ÙŠØ³ Ù…Ø³Ø¤ÙˆÙ„Ø§Ù‹ Ø­Ø§Ù„ÙŠÙ‹Ø§.")

    # --- Ø£Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø®ØµØµØ© ---
    elif command == "Ù…Ù„Ù":
        await handle_file_management_command(event)

# --- Ù…Ø¹Ø§Ù„Ø¬ ØªÙØ§Ø¹Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± (Callback Query) ---
@client.on(events.CallbackQuery())
async def callback_handler(event):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø´ÙØ§ÙØ©."""
    if is_admin(event):
        command = event.data.decode('utf-8')

        if command.startswith(".t") and len(command) > 2 and command[2:].isdigit():
            await event.answer("Ø£Ø¯Ø®Ù„ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:")
            await event.edit(f"Ø£Ø¯Ø®Ù„ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù€ `{command}`:")
            
            async def wait_for_new_price(e):
                if e.sender_id == event.sender_id and e.text and e.text.strip().lstrip('-').isdigit():
                    new_value = int(e.text)
                    if command == ".t1":
                        global PRICE_PER_PAGE_LT50
                        PRICE_PER_PAGE_LT50 = new_value
                        await e.reply(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (Ø£Ù‚Ù„ Ù…Ù† 50 ØµÙØ­Ø©) Ø¥Ù„Ù‰: `{PRICE_PER_PAGE_LT50}`")
                    elif command == ".t2":
                        global PRICE_PER_PAGE_GTE50
                        PRICE_PER_PAGE_GTE50 = new_value
                        await e.reply(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (50 ØµÙØ­Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±) Ø¥Ù„Ù‰: `{PRICE_PER_PAGE_GTE50}`")
                    elif command == ".t3":
                        global COVER_BINDING_COST
                        COVER_BINDING_COST = new_value
                        await e.reply(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯ Ø¥Ù„Ù‰: `{COVER_BINDING_COST}`")
                    await save_settings()
                    await send_settings_menu(e)
                    return True # ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
                return False
            
            client.add_event_handler(wait_for_new_price, events.NewMessage(incoming=True, from_users=event.sender_id))
            return # Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ù‡Ù†Ø§ Ù„Ø£Ù†Ù†Ø§ Ù†Ù†ØªØ¸Ø± Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…

        if command in [".ØªÙØ¹ÙŠÙ„", ".ÙØ­Øµ", ".Ù†Ø§ÙŠÙ…", ".ÙƒØ§Ø¹Ø¯", ".Ø³Ø¬Ù„", ".Ø·Ø¨Ø§Ø¹Ø©", ".Ø³Ø¹Ø±", ".ØªÙŠØ³Øª", ".Ø§Ø°Ø§Ø¹Ø©", ".Ù…Ù„Ù"]:
            await event.delete() # Ø­Ø°Ù Ø§Ù„Ø²Ø± Ø§Ù„Ø°ÙŠ ØªÙ… Ø§Ù„Ø¶ØºØ· Ø¹Ù„ÙŠÙ‡
            await event.client.send_message(event.chat_id, f"{command}")
            return

        if command == ".Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª":
            await send_settings_menu(event) # Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
            return

        if command == ".Ù…Ù„Ù":
            await handle_file_management_command(event)
            return

    await event.answer("Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±.")

async def send_settings_menu(event):
    """Ø¥Ø±Ø³Ø§Ù„ Ù‚Ø§Ø¦Ù…Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙƒØ£Ø²Ø±Ø§Ø± Ø´ÙØ§ÙØ©."""
    await event.edit("âš™ï¸ **Ù‚Ø§Ø¦Ù…Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:**\n\n"
                     f"1.  **Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (<50):** `{PRICE_PER_PAGE_LT50}`\n"
                     f"2.  **Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (>=50):** `{PRICE_PER_PAGE_GTE50}`\n"
                     f"3.  **ØªÙƒÙ„ÙØ© Ø§Ù„ØªØ¬Ù„ÙŠØ¯:** `{COVER_BINDING_COST}`\n\n"
                     "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù‚Ù… Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©.")
    keyboard = [
        [KeyboardButtonCallback(text="ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± 1", callback_data=".t1"),
         KeyboardButtonCallback(text="ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± 2", callback_data=".t2")],
        [KeyboardButtonCallback(text="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ¬Ù„ÙŠØ¯", callback_data=".t3")],
        [KeyboardButtonCallback(text="Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data=".Ù…Ø³Ø§Ø¹Ø¯Ø©")] # Ø²Ø± Ù„Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
    ]
    await event.edit(reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard))

# --- 8. Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¹Ø§Ø¯ÙŠÙŠÙ† ---
@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private and not e.out and not is_admin(e)))
async def handle_user_message(event):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¹Ø§Ø¯ÙŠÙŠÙ†."""
    sender_id = event.sender_id

    if sender_id in ignored_users:
        return

    all_known_users.add(sender_id)

    if is_sleeping:
        await event.reply(custom_auto_reply_message or "â³ Ø£Ù†Ø§ Ù†Ø§Ø¦Ù… Ø­Ø§Ù„ÙŠÙ‹Ø§. Ø³Ø£Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ù‹Ø§.")
        return

    if event.document:
        status_message = await event.reply("â³ **Ø¬Ø§Ø±ÙŠ Ø§Ø³ØªÙ„Ø§Ù… ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù. Ø³Ù†Ù‚ÙˆÙ… Ø¨Ø¥Ø¨Ù„Ø§ØºÙƒ Ø¨Ø§Ù„ØªÙƒÙ„ÙØ© Ù‚Ø±ÙŠØ¨Ø§Ù‹.**")
        path = await download_file(event, DOWNLOAD_PATH, status_message)
        if path:
            pages = await count_pages_for_document(path)
            if pages > 0:
                price_no_cover, price_with_cover = await calculate_price(pages)
                await event.client.send_message(event.chat_id,
                    f"ğŸ“„ **ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­.**\n"
                    f"**Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù:** `{os.path.basename(path)}`\n"
                    f"**Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª:** {pages}\n"
                    f"ğŸ’° **Ø§Ù„ØªÙƒÙ„ÙØ© (Ø¨Ø¯ÙˆÙ† ØªØ¬Ù„ÙŠØ¯):** `{price_no_cover}`\n"
                    f"ğŸ’° **Ø§Ù„ØªÙƒÙ„ÙØ© (Ù…Ø¹ ØªØ¬Ù„ÙŠØ¯):** `{price_with_cover}`\n\n"
                    f"ÙŠØ±Ø¬Ù‰ ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨Ùƒ."
                )
            else:
                await event.client.send_message(event.chat_id, "âŒ **Ø¹Ø°Ø±Ø§Ù‹. Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† ØªØ­Ø¯ÙŠØ¯ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù.**")
            try: os.remove(path)
            except OSError as e: logger.warning(f"ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª: {e}")
        else:
            pass
    else:
        user_name = get_user_full_name(await event.get_sender())
        await event.reply(DEFAULT_WELCOME_MESSAGE.format(user_name=user_name))


# --- 9. Ø¯Ø§Ù„Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø®ØµØµØ© ---
async def handle_file_management_command(event):
    """ÙŠØ¹Ø§Ù„Ø¬ Ø£Ù…Ø± .Ù…Ù„Ù Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø®ØµØµØ©."""
    current_dir = os.path.dirname(os.path.abspath(__file__))
    python_files = [
        f for f in os.listdir(current_dir) 
        if f.endswith('.py') 
        and f != os.path.basename(__file__) 
        and f != 'config.ini' # Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    ]

    if not python_files:
        await event.edit("â„¹ï¸ **Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ø¨Ø§ÙŠØ«ÙˆÙ† Ù…Ø®ØµØµØ© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø¬Ù„Ø¯.**\n"
                         "âœ… **Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³Ù… `new_script.py`.**\n"
                         "â¡ï¸ **ÙŠØ±Ø¬Ù‰ Ù†Ù‚Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ø¥Ù„ÙŠÙ‡ Ø«Ù… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± `.Ù…Ù„Ù` Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.**")
        try:
            new_script_content = """# Ù‡Ø°Ø§ Ù…Ù„Ù ÙƒÙˆØ¯ Ù…Ø®ØµØµ Ù„ØªØ´ØºÙŠÙ„Ù‡ Ø¹Ø¨Ø± Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ.


"""
            with open(os.path.join(current_dir, "new_script.py"), "w", encoding='utf-8') as f:
                f.write(new_script_content)
            logger.info("ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù new_script.py Ø¨Ù†Ø¬Ø§Ø­.")
        except Exception as e:
            logger.error(f"ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù new_script.py: {e}")
        return

    file_list_message = "ğŸ“œ **Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨Ø§ÙŠØ«ÙˆÙ† Ø§Ù„Ù…Ø®ØµØµØ© Ø§Ù„Ù…ØªØ§Ø­Ø©:**\n\n"
    for i, filename in enumerate(python_files):
        file_list_message += f"{i+1}. `{filename}`\n"
    file_list_message += "\n**Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ´ØºÙŠÙ„Ù‡.**"

    await event.edit(file_list_message)

    async def wait_for_file_choice(e):
        if e.sender_id == event.sender_id and e.text and e.text.strip().isdigit():
            choice = int(e.text)
            if 1 <= choice <= len(python_files):
                selected_file = python_files[choice - 1]
                await execute_custom_script(e, selected_file)
                return True # ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        return False

    client.add_event_handler(wait_for_file_choice, events.NewMessage(incoming=True, from_users=event.sender_id))

async def execute_custom_script(event, script_name):
    """ÙŠØ´ØºÙ„ Ù…Ù„Ù Ø¨Ø§ÙŠØ«ÙˆÙ† Ù…Ø®ØµØµ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ù…Ù†ÙØµÙ„Ø©."""
    script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), script_name)
    await event.edit(f"ğŸš€ **Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù `{script_name}`...**")
    try:
        env_vars = {
            "API_ID": str(API_ID) if API_ID is not None else '',
            "API_HASH": API_HASH if API_HASH is not None else '',
            "SESSION_STRING": SESSION_STRING if SESSION_STRING is not None else '',
            "PRINTING_GROUP_ID": str(PRINTING_GROUP_ID) if PRINTING_GROUP_ID is not None else '',
            "ADMIN_IDS": ",".join(map(str, ADMIN_IDS)), # ØªÙ…Ø±ÙŠØ± Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙƒÙ…ØªØºÙŠØ± Ø¨ÙŠØ¦Ø©
            "OWNER_ID": str(owner_id) if owner_id is not None else '',
            "BOT_DOWNLOAD_PATH": BOT_DOWNLOAD_PATH,
            "SETTINGS_FILE": SETTINGS_FILE,
            "CURRENT_USER_ID": str(event.sender_id), # Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ Ø§Ø³ØªØ¯Ø¹Ù‰ Ø§Ù„Ù…Ù„Ù
            "SCRIPT_NAME": script_name,
        }

        process = await asyncio.create_subprocess_exec(
            sys.executable,
            script_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env={**os.environ, **env_vars} # Ø¯Ù…Ø¬ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        )
        stdout, stderr = await process.communicate()

        stdout_decoded = stdout.decode('utf-8', errors='ignore').strip()
        stderr_decoded = stderr.decode('utf-8', errors='ignore').strip()

        if process.returncode == 0:
            if not stdout_decoded and not stderr_decoded:
                await event.edit(f"âœ… **ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù `{script_name}` Ø¨Ù†Ø¬Ø§Ø­.** (Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¥Ø®Ø±Ø§Ø¬ Ù…Ø±Ø¦ÙŠ)")
            else:
                await event.edit(f"âœ… **ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù `{script_name}` Ø¨Ù†Ø¬Ø§Ø­.**\n"
                                 f"**Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ (stdout):**\n```\n{stdout_decoded}\n```")
        else:
            await event.edit(f"âŒ **ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù `{script_name}`.**\n"
                             f"**Ø±Ù…Ø² Ø§Ù„Ø®Ø±ÙˆØ¬:** {process.returncode}\n"
                             f"**Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ (stderr):**\n```\n{stderr_decoded}\n```"
                             f"\n**Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ (stdout):**\n```\n{stdout_decoded}\n```")

    except FileNotFoundError:
        await event.edit(f"âŒ **Ø§Ù„Ù…Ù„Ù `{script_name}` ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­.**")
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø®ØµØµ '{script_name}': {e}", exc_info=True)
        await event.edit(f"âŒ **Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù `{script_name}`:**\n`{e}`")

# --- 10. Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ---
async def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª."""
    global owner_id, bot_start_time, ADMIN_IDS

    if not load_settings():
        logger.error("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ù† config.ini. Ù‚Ø¯ ØªÙƒÙˆÙ† Ø¨Ø¹Ø¶ Ø§Ù„Ù‚ÙŠÙ… ØºÙŠØ± ØµØ­ÙŠØ­Ø©. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø­ÙŠØ«Ù…Ø§ Ø£Ù…ÙƒÙ†.")
        if not all([API_ID, API_HASH, SESSION_STRING]):
            print("\n!!! ERROR: Critical Telegram credentials (API ID, API HASH, SESSION_STRING) are missing or invalid in config.ini. Bot cannot start. !!!")
            sys.exit(1)

    if not all([API_ID, API_HASH, SESSION_STRING]):
        print("\n!!! ERROR: Telegram API credentials are not configured correctly. Please check config.ini. !!!")
        logger.critical("Telegram API credentials are not configured correctly. Bot cannot start.")
        sys.exit(1)

# --- ØªÙ‡ÙŠØ¦Ø© Ø¹Ù…ÙŠÙ„ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ---
from telethon import TelegramClient
from telethon.sessions import StringSession
import asyncio
from datetime import datetime

client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)

async def main():
    await client.start()
    me = await client.get_me()
    owner_id = me.id
    bot_start_time = datetime.now()
    logger.info(f"âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† ÙƒÙ€ {me.first_name} [{me.id}]")

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")
        elif event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")

    await client.run_until_disconnected()

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")
        elif event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")

    await client.run_until_disconnected()

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")
        elif event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ! Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")

    await client.run_until_disconnected()

asyncio.run(main())

async def main():
    logger.info("â³ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰...")
    await client.start()
    me = await client.get_me()
    owner_id = me.id
    bot_start_time = datetime.now()
    logger.info(f"âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† ÙƒÙ€ {me.first_name} [{me.id}]")

# --- ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¯Ø§Ù„Ø© ---
asyncio.run(main())
# --- ØªÙ‡ÙŠØ¦Ø© Ø¹Ù…ÙŠÙ„ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ---
from telethon import TelegramClient
from telethon.sessions import StringSession
import asyncio
from datetime import datetime

client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)

async def main():
    await client.start()
    me = await client.get_me()
    owner_id = me.id
    bot_start_time = datetime.now()
    logger.info(f"âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† ÙƒÙ€ {me.first_name} [{me.id}]")

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")
        elif event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")

    await client.run_until_disconnected()

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")
        elif event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")

    await client.run_until_disconnected()

    @client.on(events.NewMessage)
    async def welcome(event):
        if event.is_group:
            await event.reply("ğŸ‘‹ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø±ÙˆØ¨!")
        elif event.is_private:
            await event.reply("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ! Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­.")

    await client.run_until_disconnected()

asyncio.run(main())

async def main():
    logger.info("â³ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰...")
    await client.start()
    me = await client.get_me()
    owner_id = me.id
    bot_start_time = datetime.now()
    logger.info(f"âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† ÙƒÙ€ {me.first_name} [{me.id}]")

# --- ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¯Ø§Ù„Ø© ---
asyncio.run(main())

BASE_PATH = os.path.dirname(os.path.abspath(__file__))
BOT_DOWNLOAD_PATH = os.path.join(BASE_PATH, "Bot_Downloads")
asyncio.run(main())
try:
    loop.run_until_complete(main())
except KeyboardInterrupt:
    logger.info("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙŠØ¯ÙˆÙŠØ§Ù‹.")
except Exception as e:
    logger.critical(f"ğŸ’¥ ÙØ´Ù„ Ø³ÙˆØ±Ø³ Ø§Ù„Ù…ØµØ·ÙÙ‰ ÙÙŠ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø³Ø¨Ø¨ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {e}", exc_info=True)
    print("\nPress Enter to exit...")
    input()
